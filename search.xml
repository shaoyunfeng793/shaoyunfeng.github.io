<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux:Nginx配置nodejs服务器</title>
      <link href="/2023/12/29/nginx-nodeServer/"/>
      <url>/2023/12/29/nginx-nodeServer/</url>
      
        <content type="html"><![CDATA[<h3 id="Nginx配置nodejs服务器"><a href="#Nginx配置nodejs服务器" class="headerlink" title="Nginx配置nodejs服务器"></a>Nginx配置nodejs服务器</h3><h4 id="1-安装nodejs"><a href="#1-安装nodejs" class="headerlink" title="1. 安装nodejs"></a>1. 安装nodejs</h4><p><em>通过wget安装nodejs，安装路径为<code>/user/local/src</code>下新建的<code>node</code>目录</em></p><pre><code class="bash">cd  /usr/local/src mkdir nodewget https://npm.taobao.org/mirrors/node/v12.18.2/node-v12.18.2-linux-x64.tar.xztar -xvf node-v12.18.2-linux-x64.tar.xz #解压node安装包mv node-v12.18.2-linux-x64 nodejs #把解压后文件名改成nodejs，不然名字太长了cd nodejs/bin# 接下来就是配置环境pathln -s /usr/local/src/node/nodejs/bin/node /usr/local/bin/nodeln -s /usr/local/src/node/nodejs/bin/npm /usr/local/bin/npm# 执行上面2个指令，可以全局使用node、npmnode -v #输出版本号npm -v #输出版本号#安装pm2：node进程管理工具npm i -g pm2# 接下来还是是配置环境pathln -s /usr/local/src/node/nodejs/bin/pm2  /usr/local/bin/pm2# 执行上面指令，可以全局使用pm2pm2 -v #输出版本号pm2 start app.js #运行app.js程序：即服务器程序</code></pre><h6 id="Node服务器Code"><a href="#Node服务器Code" class="headerlink" title="Node服务器Code"></a>Node服务器Code</h6><p><em>这里就简单使用<code>express</code>搭建node服务器</em></p><pre><code class="js">// app.jsconst express = require(&quot;express&quot;);const router = express.Router();const https = require(&quot;https&quot;);const url = require(&quot;url&quot;);const app = express();app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.all(&quot;*&quot;, function (req, res, next) &#123;  //设置允许跨域的域名，*代表允许任意域名跨域  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  //允许的header类型  res.header(    &quot;Access-Control-Allow-Headers&quot;,    &quot;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&quot;  );  //跨域允许的请求方式  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;);  if (req.method.toLowerCase() == &quot;options&quot;)    res.send(200); //让options尝试请求快速结束  else next();&#125;);app.use(router);router.get(&quot;/&quot;, (req, res) =&gt; &#123;  res.send(&quot;Wellcome Express&quot;);&#125;);router.post(&quot;/api/returnData&quot;, (req, res) =&gt; &#123;  console.log(req.body);  const endpoint = &quot;https://xxx.com&quot;;  // 别人服务器API地址  const parsedEndpoint = url.parse(endpoint);   const postData = JSON.stringify(req.body);  const options = &#123;    hostname: parsedEndpoint.hostname,    port: parsedEndpoint.port,    path: parsedEndpoint.path,    method: &quot;POST&quot;,    headers: &#123;      &quot;Content-Type&quot;: &quot;application/json&quot;,      &quot;Content-Length&quot;: postData.length,    &#125;,  &#125;;  const request = https.request(options, (res1) =&gt; &#123;    //检验状态码，如果成功接收数据    if (res1.statusCode === 200) &#123;      res1.setEncoding(&quot;utf8&quot;);      res1.on(&quot;data&quot;, (chunk) =&gt; &#123;        res.send(JSON.parse(chunk));      &#125;);    &#125;  &#125;);  request.on(&quot;error&quot;, (e) =&gt; &#123;    res.send(&#123;      code: -1,      data: e.message,      message: &quot;请求错误&quot;,    &#125;);    console.error(`problem with request: $&#123;e.message&#125;`);  &#125;);  request.write(postData);  request.end();&#125;);app.listen(8080, () =&gt; &#123;  console.log(&quot;Server Running...&quot;);&#125;);</code></pre><h4 id="2-配置Nginx"><a href="#2-配置Nginx" class="headerlink" title="2. 配置Nginx"></a>2. 配置Nginx</h4><p><em>进入到你的nginx&#x2F;conf&#x2F;，<code>vim nginx.conf</code>，只展示对应配置（其余不变）</em></p><pre><code>server &#123;    listen 80;    server_name 服务器域名;    # 这个是配置前端项目    location / &#123;        root html/你的项目;        index index.html;    &#125;    # 这个是接口代理，把你前端项目的/api请求都反向代理到8080端口的node服务器    location /api/ &#123;        proxy_pass http://127.0.0.1:8080/;     &#125;&#125;</code></pre><p><em>配置后还需要去nginx&#x2F;sbin&#x2F;下，执行<code>./nginx -s reload</code>重启下nginx</em></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS获取用户IP及所在省市区</title>
      <link href="/2023/06/06/js-getIPaddr/"/>
      <url>/2023/06/06/js-getIPaddr/</url>
      
        <content type="html"><![CDATA[<h3 id="获取用户IP及所在省市区"><a href="#获取用户IP及所在省市区" class="headerlink" title="获取用户IP及所在省市区"></a>获取用户IP及所在省市区</h3><p><strong>ps:</strong> <em>1.通过<code>https://api.ipify.org?format=json</code>来获取当前用户<code>ip</code>（format可以为其他方式，如js&#x2F;jsonp拼接个callback）；2.通过百度查询ip地址的api查询省市区</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    ; (function () &#123;        const ajax = function (url, cb = function () &#123; &#125;) &#123;            let xhr;            if (window.XMLHttpRequest) &#123;                xhr = new XMLHttpRequest();            &#125; else if (window.ActiveObject) &#123;//兼容IE6以下版本                xhr = new ActiveXobject(&#39;Microsoft.XMLHTTP&#39;);            &#125;            xhr.open(&quot;GET&quot;, url, true);            xhr.send(null);            xhr.onreadystatechange = function () &#123;                if (xhr.readyState == 4) &#123;                    typeof cb === &#39;function&#39; &amp;&amp; cb(JSON.parse(xhr.responseText))                &#125;            &#125;        &#125;        ajax(&#39;https://api.ipify.org?format=json&#39;, function (d1) &#123;            let ip = d1.ip;            ajax(&#39;https://qifu-api.baidubce.com/ip/geo/v1/district?ip=&#39; + ip, function (d2) &#123;                d2.data.ip = ip;                window.syf_ip_addr = d2.data;            &#125;)        &#125;)    &#125;)();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化：你所需要知道的最新的babel兼容性实现方案</title>
      <link href="/2023/02/28/babel-%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E6%A1%88/"/>
      <url>/2023/02/28/babel-%E5%85%BC%E5%AE%B9%E6%80%A7%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-core-js"><a href="#1-core-js" class="headerlink" title="1.core-js"></a>1.core-js</h3><p><code>core-js</code>是JavaScript的模块化标准库，包括了ECMAScript到2021年的新api的向后兼容实现。它和<code>babel</code>高度集成，是babel解决新特性在浏览器中兼容问题的核心依赖。</p><p>目前<code>core-js</code>的版本是<code>3.x</code>，与<code>core-js@2</code>相比不仅在本身的架构上有重大调整，还对babel中的一些插件有重大影响。</p><h4 id="1-1-core-js-2"><a href="#1-1-core-js-2" class="headerlink" title="1.1 core-js@2"></a>1.1 core-js@2</h4><p><code>core-js@2</code>被<code>@babel/polyfill</code>、<code>@babel/preset-env</code>和<code>@babel/runtime-corejs2</code>引入来进行新api的兼容处理，其中有两个核心的模块：</p><p><code>library</code>：不污染全局的runtime模块，供<code>@babel/runtime-corejs2</code>引入；<br><code>modules</code>：污染全局的polyfill模块，供<code>@babel/polyfill和@babel/preset-env</code>引入。</p><p><strong>不污染全局的runtime模块主要是采用模拟替换api的方式解决兼容性问题；污染全局的polyfill模块主要是采用在全局和实例上添加api的方式解决兼容性问题。</strong></p><h4 id="1-2-core-js-3"><a href="#1-2-core-js-3" class="headerlink" title="1.2 core-js@3"></a>1.2 core-js@3</h4><p><code>core-js@3</code>放弃了对<code>@babel/polyfill</code>的支持，被<code>@babel/preset-env</code>和<code>@babel/runtime-corejs3</code>引入来进行新api的兼容处理。</p><p>由于<code>core-js@2</code>包的体积太大（约2M），并且有很多重复的文件被引用。所以，<code>core-js@3</code>对包进行拆分，其中两个核心的包分别是：</p><ul><li><code>core-js</code>：污染全局的polyfill包，供<code>@babel/preset-env</code>引入，等价于<code>core-js@2/modules</code>（约500k, 40k minified and gzipped）；</li><li><code>core-js-pure</code>：不污染全局的runtime包，供<code>@babel/runtime-corejs3</code>引入，等价于<code>core-js@2/library</code>（约440k）。</li></ul><p><code>core-js@2</code>分支已经冻结，不会再添加新特性，新特性都会添加到<code>core-js@3</code>。例如你使用了 Array.prototype.flat()，如果你使用的是<code>core-js@2</code>，那么其不包含此新特性。但是你仍然可以在<code>core-js@3</code>的基础上使用<code>core-js@2</code>的功能。为了可以使用更多的新特性，建议大家使用<code>core-js@3</code>。</p><p><em>关于core-js的内容大家先了解这么多，先有个印象，大家只需要记住一点: <code>corejs</code>才是api兼容实现的提供者❗❗</em></p><h3 id="2-babel-x2F-preset-env"><a href="#2-babel-x2F-preset-env" class="headerlink" title="2.@babel&#x2F;preset-env"></a>2.@babel&#x2F;preset-env</h3><p>babel自6.0起，就不再对代码进行transform，现在只负责parse和generate过程，代码的transform过程全都交给一个个plugin去做。所以在没有配置任何plugin的情况下，经过babel输出的代码是没有改变的。</p><p>有的环境下可能需要转换几十种不同语法的代码，则需要配置几十个plugin，这显然会非常繁琐。所以，为了解决这种问题，babel提供了预设插件机制preset，preset中可以预设置一组插件来便捷的使用这些插件所提供的功能。目前，babel官方推荐使用<code>@babel/preset-env</code>预设插件。</p><p><code>@babel/preset-env</code>主要的作用是用来转换那些已经被正式纳入TC39中的语法。所以它无法对那些还在提案中的语法进行处理，对于处在stage中的语法，需要安装对应的plugin进行处理。</p><pre><code>&#123;  &quot;presets&quot;: [    [&quot;@babel/preset-env&quot;]  ]&#125;</code></pre><p>除了语法转换，<code>@babel/preset-env</code>另一个重要的功能是对api的处理，也就是在代码中引入polyfill。但是，<code>@babel/preset-env</code>默认是不开启处理api的功能，只有设置了<code>useBuiltIns</code>选项（不为false）才会开启。</p><p><code>@babel/preset-env</code>主要还是依赖<code>core-js</code>来处理api的兼容性，在升级到<code>7.4.0</code>以上的版本以后，既支持<code>core-js@2</code>，也支持<code>core-js@3</code>，所以增加了corejs的配置来控制所需的版本。如果设置了<code>useBuiltIns</code>选项（不为false）就得设置corejs版本，否则babel将会发出警告。</p><pre><code>&#123;  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      &#123;        &quot;useBuiltIns&quot;: &quot;usage&quot;, // 也可配置成 entry，配置为 false 则不需要配置 corejs        &quot;corejs&quot;: 3// 也可配置成 2      &#125;    ]  ]&#125;</code></pre><p><code>useBuiltIns</code>是babel7的新功能，这个配置提供了三个选项告诉babel该如何引入polyfill包：</p><h4 id="2-1-usage"><a href="#2-1-usage" class="headerlink" title="2.1 usage"></a>2.1 usage</h4><p>代码中不用主动import，babel会自动将代码里已使用到的且browserslist环境不支持的polyfill导入。<br><em>当然如果您需要自己试一试编译结果的话，可以到babel官网上的在线工具试一试 <a href="https://www.babeljs.cn/repl">https://www.babeljs.cn/repl</a></em></p><p><strong>编译前：</strong></p><pre><code class="js">const result = [1, 2, 3, 4, 5].copyWithin(0, 3)const instance = newPromise((resolve, reject) =&gt; &#123;  resolve(123)&#125;)</code></pre><p><strong>编译后：</strong></p><pre><code class="js">&quot;use strict&quot;;require(&quot;core-js/modules/es.array.copy-within.js&quot;);require(&quot;core-js/modules/es.object.to-string.js&quot;);require(&quot;core-js/modules/es.promise.js&quot;);var result = [1, 2, 3, 4, 5].copyWithin(0, 3);var instance = newPromise(function (resolve, reject) &#123;  resolve(123);&#125;);</code></pre><h4 id="2-2-entry"><a href="#2-2-entry" class="headerlink" title="2.2 entry"></a>2.2 entry</h4><p>需要在代码运行之前导入，会将browserslist环境不支持的所有polyfill都导入。</p><p><strong>编译前：</strong></p><pre><code class="js">import&quot;core-js/stable&quot;;import&quot;regenerator-runtime/runtime&quot;;const result = [1, 2, 3, 4, 5].copyWithin(0, 3)const instance = newPromise((resolve, reject) =&gt; &#123;  resolve(123)&#125;)</code></pre><p><strong>编译后：</strong></p><pre><code class="js">&quot;use strict&quot;;require(&quot;core-js/modules/es.symbol.js&quot;);// ... 此处省略400+行代码require(&quot;regenerator-runtime/runtime&quot;);var result = [1, 2, 3, 4, 5].copyWithin(0, 3);var instance = newPromise(function (resolve, reject) &#123;  resolve(123);&#125;);</code></pre><h4 id="2-3-false"><a href="#2-3-false" class="headerlink" title="2.3 false"></a>2.3 false</h4><p>只做了语法转换，不会导入任何polyfill进来，并且corejs配置将无效。</p><p><strong>编译前：</strong></p><pre><code class="js">const result = [1, 2, 3, 4, 5].copyWithin(0, 3)const instance = newPromise((resolve, reject) =&gt; &#123;    resolve(123)&#125;)const shen = result?.a</code></pre><p><strong>编译后：</strong></p><pre><code class="js">&quot;use strict&quot;;var result = [1, 2, 3, 4, 5].copyWithin(0, 3);var instance = newPromise(function (resolve, reject) &#123;  resolve(123);&#125;);var shen = result === null || result === void0 ? void0 : result.a;</code></pre><h3 id="3-babel-x2F-polyfill"><a href="#3-babel-x2F-polyfill" class="headerlink" title="3.@babel&#x2F;polyfill"></a>3.@babel&#x2F;polyfill</h3><p><code>@babel/polyfill</code>是一个运行时包，主要是通过核心依赖<code>core-js@2</code>来完成对应浏览器不支持的新的全局和实例api的添加。在升级到<code>core-js@3</code>后，如果还要保留<code>@babel/polyfill</code>的使用，就要在<code>@babel/polyfill</code>中添加<code>core-js@2</code>和<code>core-js@3</code>切换的选项，这样<code>@babel/polyfill</code>中将包含<code>core-js@2</code>和<code>core-js@3</code>两个包，出于这个原因官方决定弃用<code>@babel/polyfill</code>。</p><p>关于<code>@babel/polyfill</code>有三点要说明：<br>如果采用<code>@babel/preset-env</code>的polyfill方案是不需要<code>@babel/polyfill</code>的安装为前提，只需要安装<code>core-js</code>（regenerator-runtime会在安装<code>@babel/preset-env</code>的时候自动安装），然后通过设置<code>useBuiltIns</code>选项来开启对api的兼容性处理。</p><p>当然，你也可以不依赖<code>@babel/preset-env</code>提供的处理api兼容性的能力，直接使用<code>@babel/polyfill</code>来处理。如果使用了<code>core-js@3</code>，则需要做如下的替换工作：</p><pre><code class="js">// beforeimport&quot;@babel/polyfill&quot;;// afterimport&quot;core-js/stable&quot;;import&quot;regenerator-runtime/runtime&quot;;</code></pre><p><em>注：此篇文章摘自悬笔e绝一文：<a href="https://baijiahao.baidu.com/s?id=1709714903451987794&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1709714903451987794&amp;wfr=spider&amp;for=pc</a> 更多内容可从该文查看</em></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我的APP喜阅小说</title>
      <link href="/2023/02/23/xiyue-profile/"/>
      <url>/2023/02/23/xiyue-profile/</url>
      
        <content type="html"><![CDATA[<h4 id="谈谈框架"><a href="#谈谈框架" class="headerlink" title="谈谈框架"></a>谈谈框架</h4><p><em>app采用纯前端架构，无后端技术支持（全靠抓数据），使用vue搭建移动端项目，通过hbuildx构建成5+app，并打包成app</em><br><em>数据来源都是通过前端<code>xhr</code>来的， 再利用<code>jquery</code>拿到想要的数据。而且大家会疑惑xhr不会跨域吗❓ 答案是肯定的，虽然大家都知道跨域问题只在浏览器上存在，但是打包成app 毕竟是嵌套在webview下的app，如果不用原生的xhr：<code>plus.net.XMLHttpRequest</code>也是没办法跨域请求哦</em></p><p><em>当然解决跨域请求问题，当然也可以交给服务器端处理，但是因为还涉及到后端，还要买服务器啥的，直接就pass掉这种方案，嫌麻烦~</em></p><p><em>大家也可以自行下载安装使用看看👇👇</em></p><p><a href="https://postimg.cc/VJy2cDXK"><img src="https://i.postimg.cc/bwdPk5rf/app.png" alt="app.png"></a></p><h4 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h4><p><strong>废话不多说直接上代码, 因为我们的目的就是为了跨域请求所以只限在app才能使用</strong></p><pre><code class="js">// request.jsfunction plusReady(callback) &#123;    if (window.plus) &#123;        callback();    &#125; else &#123;        document.addEventListener(&#39;plusready&#39;, callback);    &#125;&#125;function request(options) &#123;    options = options || &#123;&#125;;  //调用函数时如果options没有指定，就给它赋值&#123;&#125;,一个空的Object    options.type = (options.type || &quot;GET&quot;).toUpperCase();/// 请求格式GET、POST，默认为GET    options.contentType = options.contentType || &quot;application/json&quot;;    //响应数据格式，默认json    options.headers = options.headers || [];    let params = formatParams(options.data);//options.data请求的数据    return new Promise((resolve, reject) =&gt; &#123;        plusReady(function () &#123;            try &#123;                let xhr = new plus.net.XMLHttpRequest();                //启动并发送一个请求                if (options.type == &quot;GET&quot;) &#123;                    xhr.open(&quot;GET&quot;, options.url + &quot;?&quot; + params, true);                    for (let i = 0; i &lt; options.headers.length; i++) &#123;                        xhr.setRequestHeader(options.headers[i][0], options.headers[i][1]);                    &#125;                    xhr.send();                &#125; else if (options.type == &quot;POST&quot;) &#123;                    xhr.open(&quot;post&quot;, options.url, true);                    xhr.setRequestHeader(&quot;Content-type&quot;, options.contentType);                    for (let i = 0; i &lt; options.headers.length; i++) &#123;                        xhr.setRequestHeader(options.headers[i][0], options.headers[i][1]);                    &#125;                    xhr.send(JSON.stringify(options.data));                &#125;                // 接收返回参数                xhr.onreadystatechange = function () &#123;                    if (xhr.readyState == 4) &#123;                        let status = xhr.status;                        if (status &gt;= 200 &amp;&amp; status &lt; 300 || status == 304) &#123;                            let response;                            try &#123;                                response = JSON.parse(xhr.responseText)                            &#125; catch (e) &#123;                                response = xhr.responseText                            &#125;                            resolve(response)                        &#125; else &#123;                            reject(options.url + `Error: $&#123;xhr.statusText&#125; ($&#123;xhr.status&#125;)`)                        &#125;                    &#125;                &#125;                // 设置超时时间                setTimeout(function () &#123;                    if (xhr.readySate != 4) &#123;                        xhr.abort();                        reject(&#39;Request Timeout&#39;);                    &#125;                &#125;, options.timeout || 10000);            &#125; catch (e) &#123;                reject(e)                throw new Error(&#39;只能在APP环境下请求&#39;)            &#125;        &#125;)    &#125;)&#125;function formatParams(data) &#123;    let arr = [];    for (let name in data) &#123;        arr.push(encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(data[name]));    &#125;    // arr.push((&quot;v=&quot; + Math.random()).replace(&quot;.&quot;, &quot;&quot;));    return arr.join(&quot;&amp;&quot;);&#125;export default request</code></pre><p>👇这边的代码是用来生成新的<code>document</code>的，为了方便jQuery工作👇</p><pre><code class="js">// docMaker.jsexport default function docMaker(htmlDomStr) &#123;    const doc = document.implementation.createHTMLDocument();    doc.body.innerHTML = htmlDomStr;    return doc;&#125;</code></pre><p>👇这边的代码是类似封装了API接口，请求数据＋处理数据&#x3D;想要的数据👇</p><pre><code class="js">// ReaderDriver.jsimport $ from &#39;jquery&#39;;import request from &#39;./request&#39;;import docMaker from &#39;./docMaker&#39;;import &#123; Toast &#125; from &#39;vant&#39;;const DOMAIN = &#39;https://www.biquzw.la/&#39;;function URLAfterDeal(url) &#123;    if (/^https?:\/\//.test(url)) &#123;        return url    &#125; else &#123;        return DOMAIN + url    &#125;&#125;class ReaderDriver &#123;    async search(keyword) &#123;        const result = [];        try &#123;            const res = await request(&#123;                url: DOMAIN + &#39;/modules/article/search.php&#39;,                data: &#123;                    searchkey: keyword                &#125;            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            $$.find(&#39;.grid tbody &gt; tr&#39;).each(function (i, elem) &#123;                const name = $(elem).find(&#39;td:eq(0)&#39;).text();                const article = $(elem).find(&#39;td:eq(1)&#39;).text();                const author = $(elem).find(&#39;.odd:eq(1)&#39;).text();                const path = $(elem).find(&#39;td:eq(0)&#39;).find(&#39;a&#39;).attr(&#39;href&#39;);                const status = $(elem).find(&#39;td:eq(-1)&#39;).text();                if (name &amp;&amp; author) &#123;                    result.push(                        &#123;                            type: &#39;.biquge&#39;,                            name,                            article,                            author,                            status,                            path                        &#125;                    );                &#125;            &#125;);            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取书籍信息以及章节列表    async getInfoAndChapter(pathStr) &#123;        const result = &#123;            type: &#39;.biquge&#39;,            name: &#39;&#39;,            kind: &#39;&#39;,            author: &#39;&#39;,            icon: &#39;&#39;,            desc: &#39;&#39;,            chapterList: []        &#125;;        try &#123;            const res = await request(&#123;                url: URLAfterDeal(pathStr)            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            // 数据采集            result.name = $$.find(&#39;#info h1&#39;).text();            result.author = $$.find(&#39;#info p:eq(0)&#39;).text().split(&#39;:&#39;)[1] || &#39;佚名&#39;;            result.kind = $$.find(&#39;#info p:eq(1)&#39;).text().split(&#39;:&#39;)[1] || &#39;未知&#39;;            result.icon = $$.find(&#39;#fmimg img&#39;).attr(&#39;src&#39;);            result.desc = $$.find(&#39;#intro p:eq(0)&#39;).text();            $$.find(&#39;#list dd&#39;).each(function (i, elem) &#123;                const name = $(elem).find(&#39;a&#39;).text();                const path = $(elem).find(&#39;a&#39;).attr(&#39;href&#39;);                result.chapterList.push(                    &#123;                        name,                        path: pathStr + path,                    &#125;                );            &#125;);            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取书籍章节列表    async getChapter(pathStr) &#123;        const result = [];        try &#123;            const res = await request(&#123;                url: URLAfterDeal(pathStr)            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            // 数据采集            $$.find(&#39;#list dd&#39;).each(function (i, elem) &#123;                const name = $(elem).find(&#39;a&#39;).text();                const path = $(elem).find(&#39;a&#39;).attr(&#39;href&#39;);                result.push(                    &#123;                        name,                        path: pathStr + path,                    &#125;                );            &#125;);            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取章节内容    async getContent(pathStr, rootPathStr, countLimit = 100) &#123;        const result = &#123;            title: &#39;&#39;,            content: &#39;&#39;,            totalCount: 0,            pageNo: 0,            totalPage: 0,            list: [],            prev: null,            next: null        &#125;;        try &#123;            const res = await request(&#123;                url: URLAfterDeal(pathStr)            &#125;);            const chapterList = await this.getChapter(rootPathStr);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            let title = $$.find(&#39;.bookname h1&#39;).text();            let findIndex = chapterList.findIndex(d =&gt; d.name == title);            result.title = title;            result.list = chapterList;            result.totalCount = chapterList.length;            result.pageNo = Math.floor(findIndex / countLimit);            result.totalPage = Math.ceil(chapterList.length / countLimit) - 1;            result.content = $$.find(&#39;#content&#39;).html() || &#39;&#39;;            result.prev = chapterList[findIndex - 1] || null;            result.next = chapterList[findIndex + 1] || null;            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取书籍信息    async getInfo(pathStr) &#123;        const result = &#123;&#125;;        try &#123;            const res = await request(&#123;                url: URLAfterDeal(pathStr)            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            result.icon = $$.find(&#39;#fmimg img&#39;).attr(&#39;src&#39;);            result.desc = $$.find(&#39;#intro p:eq(0)&#39;).text();            // result.name = $$.find(&#39;#info h1&#39;).text();            // result.author = $$.find(&#39;#info p:eq(0)&#39;).text().split(&#39;:&#39;)[1] || &#39;佚名&#39;;            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取推荐阅读    async getRecommend() &#123;        const result = [];        try &#123;            const res = await request(&#123;                url: DOMAIN            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            $$.find(&#39;#hotcontent .l .item&#39;).each((i, el) =&gt; &#123;                let imgTag = $(el).find(&#39;.image img&#39;);                let aTag = $(el).find(&#39;.image a&#39;);                let spanTag = $(el).find(&#39;dl dt span&#39;);                let ddTag = $(el).find(&#39;dl dd&#39;);                let icon = imgTag.attr(&#39;src&#39;)                let name = imgTag.attr(&#39;alt&#39;)                let desc = ddTag.text()                let path = aTag.attr(&#39;href&#39;)                let author = spanTag.text() || &#39;佚名&#39;                result.push(                    &#123;                        type: &#39;.biquge&#39;,                        icon,                        name,                        path,                        desc,                        author                    &#125;                );            &#125;)            $$.find(&#39;.novelslist .content .top&#39;).each((i, el) =&gt; &#123;                let imgTag = $(el).find(&#39;.image img&#39;);                let aTag = $(el).find(&#39;.image a&#39;);                let dtTag = $(el).find(&#39;dl dt&#39;);                let ddTag = $(el).find(&#39;dl dd&#39;);                let icon = imgTag.attr(&#39;src&#39;)                let name = imgTag.attr(&#39;alt&#39;)                let desc = ddTag.text()                let path = aTag.attr(&#39;href&#39;)                let author = dtTag.text().split(&#39;：&#39;)[1] || &#39;佚名&#39;                result.push(                    &#123;                        type: &#39;.biquge&#39;,                        icon,                        name,                        path,                        desc,                        author                    &#125;                );            &#125;)            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;    // 获取与排行榜    async getRank(type, limit = 10, pageNo = 1) &#123;        const result = [];        let pathStr = &#39;&#39;;        switch (type) &#123;            case &#39;week&#39;:                pathStr = &#39;/paihangbang_weekvisit/&#39; + pageNo + &#39;.html&#39;                break;            case &#39;all&#39;:                pathStr = &#39;/paihangbang_allvisit/&#39; + pageNo + &#39;.html&#39;                break;            case &#39;hot&#39;:                pathStr = &#39;/paihangbang_allvote/&#39; + pageNo + &#39;.html&#39;                break;            default:                return result;        &#125;        try &#123;            const res = await request(&#123;                url: DOMAIN + pathStr            &#125;);            let doc = docMaker();            doc.body.innerHTML = res;            let $$ = $(doc);            doc = null;            $$.find(&#39;#main li&#39;).each((i, el) =&gt; &#123;                let s2Atag = $(el).find(&#39;.s2 a&#39;);                let s4tag = $(el).find(&#39;.s4&#39;);                let name = s2Atag.text()                let author = s4tag.text() || &#39;佚名&#39;                let path = s2Atag.attr(&#39;href&#39;)                result.push(                    &#123;                        type: &#39;.biquge&#39;,                        path,                        name,                        author,                        icon: &#39;&#39;,                        desc: &#39;&#39;                    &#125;                );            &#125;)            result.splice(limit);            $$ = null;        &#125; catch (error) &#123;            Toast(&#39;数据异常，请稍后再试&#39;)            console.warn(error);        &#125;        return result;    &#125;&#125;export default new ReaderDriver();</code></pre><h4 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h4><p><strong>因为在该网站上的排行榜数据，全是只有文字，没有图片，只能通过拿到小说详情页链接，再访问在抓一次，才能拿到图片、描述的信息，这样就是相当于抓到一个数组的排行榜对象，又要在次遍历这个对象去拿到更多的信息，如果这样做就很容易导致请求不稳定，容易出现超时请求，于是我是这么解决优化的：</strong><br><em>1.先拿到纯文字的数据，有啥就先展示啥，图片没有就先占位着</em><br><em>2.等到列表数据都完整了 再去开始抓详情页的数据，在来分批更新图片，有点懒加载的味道</em></p><p>👇接下来上下代码👇</p><pre><code class="js">// ReaderDriver当然是new出来的export default &#123;  data() &#123;    return &#123;      initLoading: true,      hotList: [], // 热门      allRankList: [], // 总榜      weekRankList: [], // 周榜      recommendList: [], // 推荐阅读    &#125;  &#125;,  created() &#123;    // 这里还需要处理all其中如果有失败的问题    // 通过处理下promise数组来解决，catch：rej =&gt; []的原因是列表都是数组格式的数据    /**     *  let transferedPromise = (reqList) =&gt; &#123;            return reqList.map(item =&gt; &#123;                return item.then(res =&gt; res).catch(rej =&gt; [])            &#125;)        &#125;     *      */       Promise.all([      ReaderDriver.getRecommend(),      ReaderDriver.getRank(&#39;hot&#39;),      ReaderDriver.getRank(&#39;week&#39;),      ReaderDriver.getRank(&#39;all&#39;),    ]).then(([      res1,      res2,      res3,      res4,    ]) =&gt; &#123;      this.recommendList = Object.freeze(res1);      this.hotList = res2;      this.weekRankList = res3;      this.allRankList = res4;      this.initLoading = false;      // 分组渲染        this.fetchImg([this.hotList, this.weekRankList, this.allRankList])    &#125;)  &#125;,  methods: &#123;    fetchImg(array = []) &#123;      if (array.length == 0) &#123;        return      &#125;      const doFn = (item) =&gt; &#123;        item.forEach(d =&gt; &#123;          ReaderDriver.getInfo(d.path).then(res =&gt; &#123;            d.icon = res.icon; // 图片资源            d.desc = res.desc; // 描述文字          &#125;)        &#125;);        this.fetchImg(array);      &#125;      requestAnimationFrame(() =&gt; doFn(array.shift()));    &#125;  &#125;,&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios中断请求</title>
      <link href="/2023/02/13/axios-axiosAbort/"/>
      <url>/2023/02/13/axios-axiosAbort/</url>
      
        <content type="html"><![CDATA[<h3 id="axios中断请求"><a href="#axios中断请求" class="headerlink" title="axios中断请求"></a>axios中断请求</h3><h4 id="AbortController"><a href="#AbortController" class="headerlink" title="AbortController"></a>AbortController</h4><p>从<code>v0.22.0</code>开始，Axios支持AbortController以Fetch接口的方式取消请求：</p><pre><code class="js">    const controller = new AbortController();     axios.get(&#39;/foo/bar&#39;, &#123;        signal: controller.signal// signal 暗示；信号    &#125;).then(res =&gt; &#123;        // todo...    &#125;);    // 取消请求    controller.abort()</code></pre><h4 id="CancelToken"><a href="#CancelToken" class="headerlink" title="CancelToken"></a>CancelToken</h4><p><em>此API自v0.22.0起已弃用，不应在新项目中使用</em></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;button class=&quot;btn btn-primary&quot;&gt;GET&lt;/button&gt;    &lt;button class=&quot;btn btn-danger&quot;&gt;取消请求&lt;/button&gt;    &lt;script&gt;        btn = document.querySelectorAll(&quot;button&quot;)        const CancelToken = axios.CancelToken;        const source = CancelToken.source();                btn[0].onclick = function () &#123;            axios.get(&#39;http://localhost:3000/posts/&#39;, &#123;                cancelToken: source.token            &#125;).then(                res =&gt; console.log(res)            ).catch(                function (thrown) &#123;                    if (axios.isCancel(thrown)) &#123;                        console.log(&#39;Request canceled&#39;, thrown.message);                    &#125; else &#123;                        console.log(&quot;###&quot;, thrown)                    &#125;                &#125;)        &#125;                     btn[1].onclick = () =&gt; &#123;            source.cancel(&#39;操作已被用户取消。&#39;);        // 一次性， 取消请求(Message参数是可选的)        &#125;     &lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue实现消息轻提示</title>
      <link href="/2023/02/13/vue-toastCpn/"/>
      <url>/2023/02/13/vue-toastCpn/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h3><p><strong>ps:</strong> <em>通过插件式安装，实现toast组件，直接挂在全局Vue上，方便使用</em></p><h4 id="Toast-vue"><a href="#Toast-vue" class="headerlink" title="Toast.vue"></a>Toast.vue</h4><pre><code class="vue">&lt;template&gt;  &lt;div class = &quot;toast&quot; v-show=&quot;isShow&quot;&gt;    &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Toast&quot;,  props:&#123;    message:&#123;      type:String,      default:&#39;&#39;    &#125;,    isShow:&#123;      type:Boolean,      default: false    &#125;  &#125;,  methods:&#123;    show(message,time = 1000)&#123;      this.isShow = true;      this.message = message;      console.log(&quot;使用的是通过插件形式的Toast&quot;);      setTimeout(()=&gt;&#123;         this.isShow = false;         this.message = &#39;&#39;;      &#125;,time)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;  .toast&#123;    background: rgba(0,0,0,0.5);    font-size: 20px;    border-radius: 10px;    padding: 8px 10px;    color: white;    position: fixed;    transform: translate(-50%,-50%);    top: 50%;    left: 50%;    transition: all 3s;  &#125;&lt;/style&gt;</code></pre><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code class="js">import Toast from &quot;./Toast&quot;;export default &#123;    install(Vue)&#123;        //1.创建组件构造器        const Construct = Vue.extend(Toast);        //2.用new 的方式用组件构造器创建出来组件对象        const toast = new Construct();        //3.将组件对象手动挂载到某一个元素上        toast.$mount(document.createElement(&#39;div&#39;))        //4.toast.$el对应的就是div        document.body.appendChild(toast.$el)        //5.在原型中加入Toast        Vue.prototype.$toast = toast;    &#125;&#125;</code></pre><h4 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h4><pre><code class="js">// main.jsimport toast from &quot;./components/toast.vue&quot;  Vue.use(toast);// this.$toast.show(&quot;toast消息&quot;);</code></pre><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><h4 id="Message-vue"><a href="#Message-vue" class="headerlink" title="Message.vue"></a>Message.vue</h4><pre><code class="vue">&lt;template&gt;  &lt;div :class=&quot;`yf-message yf-message--$&#123;type&#125;`&quot; v-if=&quot;isShow&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;    // import &#123; defineProps &#125; from &#39;vue&#39;     defineProps([&quot;content&quot;, &quot;isShow&quot;, &quot;type&quot;]);&lt;/script&gt;</code></pre><h4 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h4><pre><code class="js">import Message from &#39;./message.vue&#39;import &#123; createVNode, render &#125; from &#39;vue&#39;let _timer = null;let _mountNode = null;const Msg = function (&#123; content = &#39;&#39;, type = &#39;info&#39;, duration = 1500 &#125;) &#123;    if (_timer) &#123;        clearTimeout(_timer);        Msg.romove();    &#125;    const message = createVNode(Message, &#123;        content: content,        type: type,        isShow: true    &#125;);    _mountNode = document.createElement(&#39;div&#39;);    render(message, _mountNode);    document.body.appendChild(_mountNode);    // 该去了    _timer = setTimeout(Msg.romove, duration)&#125;Msg.romove = function () &#123;    document.body.removeChild(_mountNode);    _timer = null;&#125;Msg.success = function (content, duration) &#123;    Msg(&#123;        content,        duration,        type: &#39;success&#39;    &#125;)&#125;Msg.error = function (content, duration) &#123;    Msg(&#123;        content,        duration,        type: &#39;error&#39;    &#125;)&#125;export default Msg</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>H5+移动端开发小杂</title>
      <link href="/2023/02/10/skill-mobileH5/"/>
      <url>/2023/02/10/skill-mobileH5/</url>
      
        <content type="html"><![CDATA[<p><strong>记录一下工作中开发移动端h5时，用到的一些little skill</strong></p><h4 id="微信实现跳转到公众号关注页"><a href="#微信实现跳转到公众号关注页" class="headerlink" title="微信实现跳转到公众号关注页"></a>微信实现跳转到公众号关注页</h4><p><em>可通过biz值来实现链接跳转</em><br>获取<code>biz</code>值可以通过公众号后台发布的历史文章找一篇复制其链接（链接上就有<code>biz</code>值），如果没有发过文章那就发一篇，同样前面的操作，然后通过拼接链接实现：</p><pre><code class="js">location.href = `https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=$&#123;你的biz&#125;#wechat_redirect`</code></pre><h4 id="微信-amp-支付宝"><a href="#微信-amp-支付宝" class="headerlink" title="微信&amp;支付宝"></a>微信&amp;支付宝</h4><pre><code class="js">// 打开微信扫一扫 location.href = &#39;weixin://scanqrcode&#39;// 微信可拉起app stroe (❌哒咩了，被微信克制了)location.href = &#39;https://itunes.apple.com/app/idxxxxxxxx&#39;// 打开支付宝扫一扫location.href = &#39;alipays://platformapi/startapp?saId=10000007&amp;qrcode=https://qr.alipay.com/bax02911brluc2xieoph6001&#39;// 支付宝打开指定页面location.href = &#39;alipays://platformapi/startapp?appId=20000067&amp;url=https%3A%2F%2Fwww.baidu.com&#39;// 更多快捷指令合集（知乎）： https://zhuanlan.zhihu.com/p/582472115</code></pre><h4 id="解决Safari浏览器不能自动播放视频"><a href="#解决Safari浏览器不能自动播放视频" class="headerlink" title="解决Safari浏览器不能自动播放视频"></a>解决Safari浏览器不能自动播放视频</h4><p><strong>增加muted、 playsinline属性解决ios浏览器不自动播放视频的问题，还需要🔕视频</strong></p><pre><code class="html">    &lt;video id=&quot;video&quot; muted=&quot;muted&quot; playsinline style=&quot;width: 100vw;height: 100vh;background: #000;&quot;    src=&quot;https://mdhw.oss-cn-hangzhou.aliyuncs.com/promotion/openbox.mp4&quot;&gt;&lt;/video&gt;</code></pre><h4 id="利用新浪接口获取用户ip"><a href="#利用新浪接口获取用户ip" class="headerlink" title="利用新浪接口获取用户ip"></a>利用新浪接口获取用户ip</h4><pre><code class="html">    &lt;!-- 引入新浪的js --&gt;   &lt;script src=&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt;   &lt;script&gt;        // 直接获取IP和城市名        console.log(returnCitySN[&#39;cip&#39;] + returnCitySN[&#39;cname&#39;]);   &lt;/script&gt;</code></pre><h4 id="vueWEB项目打包成app"><a href="#vueWEB项目打包成app" class="headerlink" title="vueWEB项目打包成app"></a>vueWEB项目打包成app</h4><p><strong>使用Hbuildx工具打包成5+app即可</strong></p><p>1.在hbuildx里先新建一个项目（5+app）<br>2.在vue项目中先<code>build</code>一下，生成到<code>dist目录</code><br>3.将<code>dist目录</code>下的代码全都拷贝到新建的5+app目录下，直接覆盖即可<br>4.可以点击运行到浏览器进行预览<br>5.云端打包成app需要的安卓证书、ios证书获取方式见文档</p><h5 id="安卓端侧边滑动返回监听"><a href="#安卓端侧边滑动返回监听" class="headerlink" title="安卓端侧边滑动返回监听"></a>安卓端侧边滑动返回监听</h5><p>把下面代码直接放在<code>public</code>下面的<code>index.html</code>的<code>body</code>下面即可</p><pre><code class="html">    &lt;script&gt;        const webview = plus.webview.currentWebview();        document.addEventListener(&#39;plusready&#39;, () =&gt; &#123;            //等待plus ready后再调用5+ API：            let first = null;            plus.key.addEventListener(&#39;backbutton&#39;, () =&gt; &#123;                webview.canBack((e) =&gt; &#123;                    if (e.canBack) &#123;                        webview.back();                    &#125; else &#123;                        //首次按键，提示‘再次操作退出应用’                        if (!first) &#123;                            //获取第一次点击的时间戳                            first = new Date().getTime();                            //通过H5+ API 调用Android 上的toast 提示框                            plus.nativeUI.toast(&quot;再次操作退出应用&quot;, &#123;                                duration: &#39;short&#39;                            &#125;);                            setTimeout(() =&gt; &#123;                                first = null;                            &#125;, 1000);                        &#125; else &#123;                            if (new Date().getTime() - first &lt; 1000) &#123;                                //获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次,                                plus.runtime.quit(); //退出应用                            &#125;                        &#125;                    &#125;                &#125;)            &#125;);        &#125;);    &lt;/script&gt;</code></pre><p><strong>由于vue项目打包成app其实本身就是套在webview里面运行的，所以一些跳转页面除了<code>$router.push</code>还有就是<code>location.href</code>，如果不兼容一下APP里的会导致页面返回不了，举个例子：app里有个广告banner,点击跳转http链接，结果用户侧滑会直接导致退出应用，即关闭掉了webview，因为app页面承载本身就是一个webviewObject,跳转后的http链接是直接在这个webviewObject上显示的，通过下面代码帮我们兼容跳转http(可以控制app内部打开&#x2F;外部浏览器打开)</strong></p><pre><code class="js">function toWebLink(url, openType = &#39;outside&#39;) &#123;  try &#123;    if (openType === &#39;inner&#39;) &#123;      let wv = plus.webview.getWebviewById(&#39;webview&#39;);      // plus api 创建并打开新的webview 详见：https://www.html5plus.org/doc/zh_cn/webview.html#plus.webview.open      plus.webview.open(        url,        &#39;webview&#39;,        &#123;          titleNView: &#123;            titleSize: &#39;14px&#39;,            buttons: [              &#123;                type: &#39;back&#39;,                float: &#39;left&#39;,                onclick: function () &#123;                  wv.canBack((e) =&gt; &#123;                    if (e.canBack) &#123;                      wv.back();                    &#125; else &#123;                      wv.close();                    &#125;                  &#125;);                &#125;,              &#125;,            ],          &#125;,        &#125;,        &#39;slide-in-right&#39;,        300,        function () &#123;          // console.log(&#39;打开了&#39;, JSON.stringify(plus.webview.all()));        &#125;,      );    &#125; else &#123;      plus.runtime.openURL(url);    &#125;  &#125; catch (e) &#123;    console.log(e);    window.location.href = url;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂技 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SVGA动画的使用</title>
      <link href="/2023/01/04/svga-svga/"/>
      <url>/2023/01/04/svga-svga/</url>
      
        <content type="html"><![CDATA[<h3 id="SVGA的简单使用"><a href="#SVGA的简单使用" class="headerlink" title="SVGA的简单使用"></a>SVGA的简单使用</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot;        content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;    &lt;title&gt;Svga动画&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;first_screen&quot;&gt;        &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // GitHub： https://github.com/svga/SVGAPlayer-Web    var first_screen = document.querySelector(&#39;.first_screen&#39;);    var canvas = document.getElementById(&#39;canvas&#39;)    canvas.width = window.innerWidth;    canvas.height = window.innerHeight;    var parser = new SVGA.Parser(&#39;#canvas&#39;);    var player = new SVGA.Player(&#39;#canvas&#39;);    player.loops = 1;    player.setContentMode(&#39;AspectFill&#39;)    parser.load(&#39;https://mdhw.oss-cn-hangzhou.aliyuncs.com/promotion/chou.svga&#39;, svga =&gt; &#123;        player.setVideoItem(svga)        player.startAnimation()        player.onFinished(function () &#123;            first_screen.remove()            player.clear()        &#125;)    &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="SVGA的分段播放"><a href="#SVGA的分段播放" class="headerlink" title="SVGA的分段播放"></a>SVGA的分段播放</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot;        content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;    &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;first_screen&quot;&gt;        &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;        &lt;div id=&quot;svga_btn&quot; style=&quot;width: 120px;height:120px;position: absolute;top: 44%;left: 0;right:0;margin: auto;&quot;&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;/static/js/svga.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var first_screen = document.querySelector(&#39;.first_screen&#39;);    var canvas = document.getElementById(&#39;canvas&#39;)    var svga_btn = document.getElementById(&#39;svga_btn&#39;)    var step = 0;    canvas.width = window.innerWidth;    canvas.height = window.innerHeight;    if (sessionStorage.getItem(&#39;cxm_paying&#39;) == &#39;true&#39;) &#123;        first_screen.remove()    &#125; else &#123;        var parser = new SVGA.Parser(&#39;#canvas&#39;);        var player = new SVGA.Player(&#39;#canvas&#39;);        player.setContentMode(&#39;AspectFill&#39;)        parser.load(&#39;https://mdhw.oss-cn-hangzhou.aliyuncs.com/promotion/chou.svga&#39;, svga =&gt; &#123;            player.setVideoItem(svga)            palyFrame(step);            svga_btn.addEventListener(&#39;click&#39;, function () &#123;                step++;                palyFrame(step);                svga_btn.style.display = &#39;none&#39;;            &#125;)            player.onFinished(function () &#123;                svga_btn.style.display = &#39;block&#39;;                player.clear();                if (step === 2) &#123;                    first_screen.remove()                &#125; else &#123;                    palyFrame(0)                &#125;            &#125;)        &#125;)    &#125;    function palyFrame(step) &#123;        switch (step) &#123;            case 0:                player.loops = 0;                player.startAnimationWithRange(&#123; location: 0, length: 120 &#125;);                break;            case 1:                // 第一次播放动画                player.loops = 1;                player.startAnimationWithRange(&#123; location: 120, length: 100 &#125;);                break;            case 2:                // 第二次播放动画                player.loops = 1;                player.startAnimationWithRange(&#123; location: 340, length: 150 &#125;);                break;            default:                return;        &#125;    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Svga </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue源码之数据响应原理</title>
      <link href="/2022/10/26/vue-dataReactive/"/>
      <url>/2022/10/26/vue-dataReactive/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue源码之数据响应原理"><a href="#Vue源码之数据响应原理" class="headerlink" title="Vue源码之数据响应原理"></a>Vue源码之数据响应原理</h3><p><strong>ps:</strong> <em>简单了解一下vue数据响应的原理，vue2通过es5的<code>defineProperty</code>来劫持数据，所以不兼容ie8及以下版本，vue3通过<code>Proxy</code>来进行数据劫持…</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">// 监听数据function observe(value) &#123;    if (typeof value != &#39;object&#39;) &#123;        return    &#125;    let ob;    if (value.__ob__ !== undefined) &#123;        ob = value.__ob__;    &#125; else &#123;        ob = new Observer(value);    &#125;    return ob;&#125;// 数据劫持function defineReactive(data, key, val) &#123;    if (arguments.length == 2) &#123;        val = data[key];    &#125;    // 递归监听子数据    observe(val)    //  也可使用proxy reflect方式来劫持 会更为便捷    Object.defineProperty(data, key, &#123;        get() &#123;            return val;        &#125;,        set(newVal) &#123;            console.log(&#39;触发视图更新--修改了属性:&#39; + key + &#39;;&#39;)            val = newVal;            observe(newVal);        &#125;    &#125;)&#125;// 数据观察器class Observer &#123;    constructor(val) &#123;        Object.defineProperty(val, &#39;__ob__&#39;, &#123;            value: this,            enumerable: false        &#125;);        // 遍历        this.walk(val)    &#125;    walk(val)&#123;        if (Array.isArray(val)) &#123;            val.__proto__ = ArrayMethod.prototype;            this.observeArray(val)        &#125; else &#123;            this.observeObj(val);        &#125;    &#125;    observeObj(val) &#123;        for (let k in val) &#123;            defineReactive(val, k)        &#125;    &#125;    observeArray(val) &#123;        for (let key in val) &#123;            observe(val[key])        &#125;    &#125;&#125;// 改写数组方法， 这边只改写了一个pushfunction ArrayMethod() &#123; &#125;ArrayMethod.prototype.push = function (...args) &#123;    console.log(&#39;触发视图更新--改变了数组&#39;)    const res = Array.prototype.push.apply(this, args)    // 新增的数据这些也需要去观察    this.__ob__.observeArray(args);    return res&#125;// 模拟vue $setfunction $set(data, key, val)&#123;   // 先去帮他设值   data[key] = val   // 重新遍历一下   data.__ob__.walk()   // 触发视图更新   console.log(&#39;触发视图更新&#39;, data)&#125;// 测试var obj = &#123;    a: 1,    b: &#123;        c: [1, 2, 3]    &#125;&#125;observe(obj)obj.b.c.push(4, &#123; a: 1 &#125;) // print =&gt; &quot;触发视图更新--改变了数组&quot;obj.b.c[0] = 0 // 不会触发更新视图obj.b.c[4].a = 2 // print =&gt; &quot;触发视图更新--修改了属性:a;&quot;obj.c = 33 // 不会触发更新视图$set(obj, &#39;c&#39;, 33) // 会触发更新视图,经过这部后，后面都可以通过xxx.属性 = 赋值obj.c = 44 // print =&gt; &quot;触发视图更新--修改了属性:c;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript防扒</title>
      <link href="/2022/10/25/js-fangba/"/>
      <url>/2022/10/25/js-fangba/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript防扒"><a href="#Javascript防扒" class="headerlink" title="Javascript防扒"></a>Javascript防扒</h3><p><strong>ps:</strong> <em>为了防止他人乱扒你的代码，或者分析你的接口，所以利用打开开发工具就会触发<code>debugger</code>的特性，来防扒</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">((function() &#123;    var callbacks = [],        timeLimit = 50,        open = false;    setInterval(loop, 1);    return &#123;        addListener: function(fn) &#123;            callbacks.push(fn);        &#125;,        cancleListenr: function(fn) &#123;            callbacks = callbacks.filter(function(v) &#123;                return v !== fn;            &#125;);        &#125;    &#125;    function loop() &#123;        var startTime = new Date();        debugger;        if (new Date() - startTime &gt; timeLimit) &#123;            if (!open) &#123;                callbacks.forEach(function(fn) &#123;                    fn.call(null);                &#125;);            &#125;            open = true;            window.stop();            alert(&#39;不要扒我了&#39;);            window.location.reload();        &#125; else &#123;            open = false;        &#125;    &#125;&#125;)()).addListener(function() &#123;    window.location.reload();&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOM：history的那些事</title>
      <link href="/2022/10/20/bom-router/"/>
      <url>/2022/10/20/bom-router/</url>
      
        <content type="html"><![CDATA[<h3 id="BOM：history的那些事"><a href="#BOM：history的那些事" class="headerlink" title="BOM：history的那些事"></a>BOM：history的那些事</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在前端框架都有路由组件，路由包括2种模式：<code>hash</code>、<code>history</code></p><p>而前端路由实现的原理好像和Bom对象里的<strong>history</strong>有点联系…</p><p>Emm…瞎搞一下…</p><h4 id="一、Hash模式"><a href="#一、Hash模式" class="headerlink" title="一、Hash模式"></a>一、Hash模式</h4><p>hash模式下，通过<code>location</code>来跳转，才会触发<code>hashchange</code>监听事件， 再通过<code>lcoation.hash</code>不同的<em>hash值</em>来决定渲染的组件, 路由的<em>hash模式</em>其工作方式类似</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;hash模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button onclick=&quot;turn(&#39;/#/abc&#39;)&quot;&gt;跳转到：/#/abc&lt;/button&gt;    &lt;div id=&quot;view&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    function turn(url) &#123;                let state = &#123;            a: 1,            b: 2        &#125;        // hash模式下，通过locaiton来跳转        location.href = url;        // history.pushState(state, &#39;/abc&#39;, url) // 该方式不会触发hashchange    &#125;    // 监听url的hash变化    window.addEventListener(&#39;hashchange&#39;, function (e) &#123;        console.log(&#39;旧链接：&#39; + e.oldURL)        console.log(&#39;新链接：&#39; + e.newURL)        console.log(location.hash); // =&gt; #/abc        document.getElementById(&#39;view&#39;).innerHtml = `&lt;div&gt;$&#123;location.hash&#125;组件&lt;/div&gt;`    &#125;)    // pushState replaceState都不会触发,用户前进后退或者location方式才触发    window.addEventListener(&#39;popstate&#39;, function (e)&#123;        console.log(e)    &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="二、History模式"><a href="#二、History模式" class="headerlink" title="二、History模式"></a>二、History模式</h4><p><code>pushState</code>只会改变url,不是真正的去跳转, 以下代码中跳转到 &#x2F;abc ,如果使用<code>location</code>会404,因为没有对应的资源</p><p>但是<code>pushState</code>没有相应的<code>onhistorychange</code>事件可以监听,那就只能自己写一个<code>push</code>,还有<code>historychange事件</code></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;history模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button onclick=&quot;turn(&#39;/abc&#39;)&quot;&gt;跳转到：/abc&lt;/button&gt;    &lt;div id=&quot;view&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    // 当然路由也不是这么样子的, 因为懒    var router = new Router([        &#123;            name: &#39;abc&#39;,            path: &#39;/abc&#39;,            component: &#39;abc组件(假装是个组件)&#39;,        &#125;    ]);    function turn(url) &#123;        router.push(url)    &#125;    function Router(routes) &#123;        this.routes = routes || [];        window.addEventListener(&#39;historychange&#39;, function (e) &#123;            let route = e.detail;            console.log(&#39;改变了, 拿到的路由对象是:&#39;, route)            // 渲染路由组件            document.getElementById(&#39;view&#39;).innerHTML = route.component;        &#125;)    &#125;    Router.prototype.push = function (url) &#123;        // 这么不严谨的代码,只是因为太懒        const findRoute = this.routes.find(d =&gt; d.path === url);        if (findRoute) &#123;            const ev = new CustomEvent(&#39;historychange&#39;, &#123; detail: findRoute &#125;);            // history模式下，通过pushState来跳转            history.pushState(&#123;&#125;, null, url);            // location.href = url; // 该方式不行，会404            window.dispatchEvent(ev);        &#125; else &#123;            throw(&#39;该路由不存在&#39;)        &#125;    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node：爬取某网图片</title>
      <link href="/2022/10/20/node-spider/"/>
      <url>/2022/10/20/node-spider/</url>
      
        <content type="html"><![CDATA[<h3 id="Node：爬取某网图片"><a href="#Node：爬取某网图片" class="headerlink" title="Node：爬取某网图片"></a>Node：爬取某网图片</h3><h4 id="一些依赖"><a href="#一些依赖" class="headerlink" title="一些依赖"></a>一些依赖</h4><pre><code class="bash"> npm install cheerio download async superagent superagent-charset mkdirp</code></pre><p><code>superagent</code> ajax请求库</p><p><code>cheerio</code> node版的jquery，获取dom节点</p><p><code>download</code> 下载文件库</p><p><code>superagent-charset</code> 设置字符集，不然获取到的htmlDoc会有中文乱码</p><p><code>async</code> mapLimit控制请求并发数，第一个回调是linkArr每个item项都执行的函数，处理完想要的数据后并return，第二个回调是linkArr每项都执行完后执行，返回一个err，和results，results就是包裹着第一个函数return值的数组（有点像promise.all）</p><p>码云地址：<a href="https://gitee.com/shaoyunfeng793/nodespider">https://gitee.com/shaoyunfeng793/nodespider</a></p><h4 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h4><p><a href="https://postimg.cc/2V2YCVLy"><img src="https://i.postimg.cc/13Z3cF9G/spider-mulu.png" alt="spider-mulu.png"></a><br><a href="https://postimg.cc/GHsPCs5J"><img src="https://i.postimg.cc/pXssKfQ7/spider-imgs.png" alt="spider-imgs.png"></a></p><h4 id="Nodejs-Code"><a href="#Nodejs-Code" class="headerlink" title="Nodejs Code"></a>Nodejs Code</h4><pre><code class="js">const request = require(&#39;superagent&#39;)require(&#39;superagent-charset&#39;)(request)const cheerio = require(&#39;cheerio&#39;)const download = require(&#39;download&#39;)const mkdirp = require(&#39;mkdirp&#39;)const async = require(&#39;async&#39;)const URL = require(&quot;url&quot;)// 保存地址var savePath = &#39;./img/&#39;;// 匹配URLvar UrlReg = new RegExp(/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i);// link收集器var globalLinkQueue = [];// 爬取次数var spiderCount = 0;// 爬取次数限制var spiderCountLimit = 2;spider(&#39;https://www.tupianzj.com/meinv/xiezhen/&#39;)// 校验是否是合法的hreffunction isValidHref(href) &#123;    return /\S+\.html/.test(href)&#125;// 检索a标签的hreffunction fetchLinks(&#123; $, selector, linksAry, title, link &#125;) &#123;    let aTags = $(selector), $aTag, aHref, aTitle;    let &#123; domain, hrefPrev &#125; = getHrefInfo(link)    for (let i = 0; i &lt; aTags.length; i++) &#123;        $aTag = $(aTags[i]);        aHref = $aTag.attr(&#39;href&#39;);        aTitle = title || $aTag.attr(&#39;title&#39;);        if (String(aHref).startsWith(&#39;/&#39;)) &#123;            aHref = domain + aHref        &#125; else &#123;            aHref = hrefPrev + aHref        &#125;        // 过滤：重复链接        if (!isValidHref(aHref) || linksAry.some(d =&gt; d.href == aHref)) &#123;            continue;        &#125;        linksAry.push(&#123;            title: aTitle,            href: aHref        &#125;)    &#125;&#125;// 获取当前链接的域名信息和拼接前缀function getHrefInfo(href) &#123;    let &#123; protocol, hostname &#125; = URL.parse(href);    let domain = protocol + &#39;//&#39; + hostname;    return &#123;        hrefPrev: href.split(&#39;/&#39;).slice(0, -1).join(&#39;/&#39;) + &#39;/&#39;,        domain: domain    &#125;&#125;// 请求urlfunction req(url) &#123;    return new Promise((rev, rej) =&gt; &#123;        request(&#39;GET&#39;, url)            .charset(&#39;gbk&#39;)            .buffer(true)            .set(&#39;Cookie&#39;, &#39;t=cdd3345174aba64147a802b43a0999e6; r=8221; Hm_lvt_f5329ae3e00629a7bb8ad78d0efb7273=1667359683,1667462127,1667525488; Hm_lpvt_f5329ae3e00629a7bb8ad78d0efb7273=1667538578&#39;)            .set(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&#39;)            .end(function (err, res) &#123;                if (err) &#123;                    rej(err)                    return                &#125;                rev(res)            &#125;)    &#125;)&#125;// 爬虫function spider(fetch_link) &#123;    console.log(`开始第$&#123;++spiderCount&#125;次入口爬虫...`)    req(fetch_link).then(res =&gt; &#123;        let linksAry = [];        fetchLinks(&#123;            $: cheerio.load(res.text),            selector: &#39;.list_con_box ul&gt;li&gt;a[href]&#39;,            linksAry: linksAry,            link: fetch_link        &#125;);        console.log(&#39;第一次抓取到的链接：\n&#39;, linksAry)        async.mapLimit(linksAry, 1, async function (&#123; href, title &#125;) &#123;            // 存在title：代表是抓取图片的目标地址            if (title) &#123;                // 创建目录                mkdirp(savePath + title);                let linksAry = [];                let &#123; text &#125; = await req(href);                let $$ = cheerio.load(text);                fetchLinks(&#123;                    $: $$,                    selector: &#39;.pages li&gt;a&#39;,                    linksAry: linksAry,                    link: href,                    title: title, //因为当前抓的页面里可能存在额外的图片链接地址，是属于同一分类， 防止收集链接的时候title为undefined                &#125;);                linksAry.unshift(&#123;                    title: title,                    href: href                &#125;);                return linksAry;            &#125; else &#123;                // 加入集合                if (!globalLinkQueue.some(d =&gt; d == href)) &#123;                    globalLinkQueue.push(href)                &#125;            &#125;        &#125;, (err, linksAry) =&gt; &#123;            let links = linksAry.filter(d =&gt; d != undefined).flat();            let count = 0;            let allCount = links.length;            console.log(&#39;第二次抓取到的链接：\n&#39;, links);            async.mapLimit(links, 1, async function (&#123; href, title &#125;) &#123;                let &#123; text &#125; = await req(href);                let $ = cheerio.load(text);                let imgSrc = $(&#39;.pic_tupian img&#39;).attr(&#39;src&#39;);                let &#123; domain, hrefPrev &#125; = getHrefInfo(href);                if (!UrlReg.test(imgSrc)) &#123;                    if (String(imgSrc).startsWith(&#39;/&#39;)) &#123;                        imgSrc = domain + imgSrc                    &#125; else &#123;                        imgSrc = hrefPrev + imgSrc                    &#125;                &#125;                await download(imgSrc, savePath + title);                console.log(`当前图片下载进度:$&#123;++count&#125;/$&#123;allCount&#125;\n`)            &#125;, () =&gt; &#123;                let href = globalLinkQueue.shift()                if (href &amp;&amp; spiderCount &lt;= spiderCountLimit) &#123;                    spider(href)                &#125;            &#125;)        &#125;)    &#125;).catch(err =&gt; &#123;        console.log(&#39;错误信息=》&#39;, err)    &#125;)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas之马赛克</title>
      <link href="/2022/10/20/canvas-masaike/"/>
      <url>/2022/10/20/canvas-masaike/</url>
      
        <content type="html"><![CDATA[<h3 id="Canvas之马赛克"><a href="#Canvas之马赛克" class="headerlink" title="Canvas之马赛克"></a>Canvas之马赛克</h3><p>通过<code>getImageData</code>获取到图片像素的数据，对这些像素数据进行一系列处理就能得到不一样的图片效果</p><p>使用<code>putImageData</code>把处理后的像素数据在输出到画布上</p><h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p><a href="https://postimg.cc/4710KP8z"><img src="https://i.postimg.cc/wMKYGbLb/canvas-masaike.jpg" alt="canvas-masaike.jpg"></a></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Canvas马赛克&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;    var canvas = document.getElementById(&quot;canvas&quot;);    var ctx = canvas.getContext(&quot;2d&quot;);    var img = new Image();    img.src = &#39;./img/0.jpeg&#39;;    img.onload = function () &#123;        draw(this);    &#125;    function draw(obj) &#123;        ctx.drawImage(obj, 0, 0);                var w = obj.width;        var h = obj.height;        var oImg = ctx.getImageData(0, 0, w, h);        //创建一个新的ImageData对象        var newImg = ctx.createImageData(w, h);        //马赛克的程度，数字越大越模糊        var num = 10;        //等分画布        var stepW = w / num;        var stepH = h / num;        //这里是循环画布的像素点        for (var i = 0; i &lt; stepH; i++) &#123;            for (var j = 0; j &lt; stepW; j++) &#123;                //获取一个小方格的随机颜色，这是小方格的随机位置获取的                var color = getXY(oImg, j * num + Math.floor(Math.random() * num), i * num + Math.floor(Math.random() * num));                //这里是循环小方格的像素点，                for (var k = 0; k &lt; num; k++) &#123;                    for (var l = 0; l &lt; num; l++) &#123;                        //设置小方格的颜色                        setXY(newImg, j * num + l, i * num + k, color);                    &#125;                &#125;            &#125;        &#125;        ctx.putImageData(newImg, w, 0);    &#125;    function getXY(obj, x, y) &#123;        var w = obj.width;        var h = obj.height;        var d = obj.data;        var color = [];        color[0] = obj.data[4 * (y * w + x)];        color[1] = obj.data[4 * (y * w + x) + 1];        color[2] = obj.data[4 * (y * w + x) + 2];        color[3] = obj.data[4 * (y * w + x) + 3];        return color;    &#125;    function setXY(obj, x, y, color) &#123;        var w = obj.width;        var h = obj.height;        var d = obj.data;        obj.data[4 * (y * w + x)] = color[0];        obj.data[4 * (y * w + x) + 1] = color[1];        obj.data[4 * (y * w + x) + 2] = color[2];        obj.data[4 * (y * w + x) + 3] = color[3];    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Canvas </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas之刮刮卡</title>
      <link href="/2022/10/20/canvas-guaguaka/"/>
      <url>/2022/10/20/canvas-guaguaka/</url>
      
        <content type="html"><![CDATA[<h3 id="Canvas之刮刮卡"><a href="#Canvas之刮刮卡" class="headerlink" title="Canvas之刮刮卡"></a>Canvas之刮刮卡</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>整个Demo，其实只是实现基本游戏逻辑，有些细节可继续优化，但是没有那么多空余时间了…</p><p>可谓是简版中的简版之黄金矿工 hhh…</p><p>先上个预览gif，再贴个代码…</p><p>可以上码云上看看: <a href="https://gitee.com/shaoyunfeng793/diao-wawa">https://gitee.com/shaoyunfeng793/diao-wawa</a></p><h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p><a href="https://postimg.cc/SJ0fr04G"><img src="https://i.postimg.cc/yYxp7Br2/diaowawa.gif" alt="diaowawa.gif"></a></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Canvas之钓娃娃GameDemo&lt;/title&gt;    &lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        .container &#123;            width: 100vw;            height: 100vh;            background-color: #333;            display: flex;            justify-content: center;            align-items: center;        &#125;        #canvas &#123;            display: block;            background-color: bisque;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./game.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./wawa.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./gouzi.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var game = new Game(&#123;        dom: &#39;#canvas&#39;,        onClick: function () &#123;            if (game.gouzi.status == &#39;pending&#39;) &#123;                game.gouzi.status = &#39;down&#39;;            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="Game-js"><a href="#Game-js" class="headerlink" title="Game.js"></a>Game.js</h4><pre><code class="js">!(function () &#123;    var Game = window.Game = function (&#123;        dom,        onClick = function () &#123; &#125;,    &#125;) &#123;        this.canvas = document.querySelector(dom);        this.ctx = this.canvas.getContext(&quot;2d&quot;);        // 资源管理器        this.R = &#123;&#125;;        // 渲染定时器        this.renderTimer = null;        // 娃娃数组        this.wawaArr = [];        // 钩子实例        this.gouzi = null;        // 安全域        this.safeTopHeight = 200;        // 宽高        this.canvasWidth = this.canvas.width;        this.canvasHeight = this.canvas.height;        // 游戏初始化        this.init();        // 监听点击        this.canvas.addEventListener(&quot;click&quot;, onClick)    &#125;    Game.prototype.init = function () &#123;        console.log(&quot;游戏初始化&quot;);        let xhr = new XMLHttpRequest();        let self = this;        let loadCount = 0;        xhr.onreadystatechange = function () &#123;            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;                let data = JSON.parse(xhr.responseText);                for (let i = 0; i &lt; data.length; i++) &#123;                    self.R[data[i].name] = new Image();                    self.R[data[i].name].src = data[i].img;                    self.R[data[i].name].onload = function () &#123;                        loadCount++;                        self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);                        self.ctx.save()                        self.ctx.font = &quot;20px 微软雅黑&quot;;                        self.ctx.textAlign = &quot;center&quot;;                        self.ctx.fillText(`正在加载资源($&#123;loadCount&#125;/$&#123;data.length&#125;)...`, self.canvas.width * 0.5, self.canvas.height * 0.5);                        self.ctx.restore()                        if (loadCount == data.length) &#123;                            setTimeout(() =&gt; &#123;                                // 创建钩子                                new Gouzi();                                // 创建娃娃                                new Array(5).fill(1).forEach(() =&gt; &#123;                                    new Wawa();                                &#125;);                                self.start();                            &#125;, 1000)                        &#125;                    &#125;                &#125;            &#125;        &#125;        xhr.open(&quot;get&quot;, &quot;R.json&quot;, true);        xhr.send();    &#125;    Game.prototype.start = function () &#123;        let frame = 0;        this.renderTimer = setInterval(() =&gt; &#123;            frame++;            // 清屏            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);            // 画帧数            this.ctx.font = &quot;10px 微软雅黑&quot;;            this.ctx.fillStyle = &quot;red&quot;;            this.ctx.fillText(`Frame:$&#123;frame&#125;`, 10, 20);            // 画勾子            if (this.gouzi &amp;&amp; this.gouzi.constructor === Gouzi) &#123;                this.gouzi.render();                this.gouzi.update();            &#125;            // 画娃娃            this.wawaArr.forEach(function (wawa) &#123;                wawa.render();                wawa.update();            &#125;)        &#125;, 1000 / 60)    &#125;    Game.prototype.end = function () &#123;        clearInterval(this.renderTimer);        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);        this.ctx.font = &quot;30px bold 微软雅黑&quot;;        this.ctx.textAlign = &quot;center&quot;;        this.ctx.fillStyle = &quot;red&quot;;        this.ctx.fillText(`You Win！`, this.canvas.width / 2, this.canvas.height / 2);    &#125;&#125;)()</code></pre><h4 id="Gouzi-js"><a href="#Gouzi-js" class="headerlink" title="Gouzi.js"></a>Gouzi.js</h4><pre><code class="js">!(function () &#123;    const DEG = Math.PI / 180;    var Gouzi = window.Gouzi = function () &#123;        if (game.gouzi) &#123;            return game.gouzi        &#125;        // 钩子状态: pending：等待； down: 出钩 up: 收钩        this.status = &#39;pending&#39;;        // 钩子初始长度        this.rotateDegMax = 80;        this.gouziLong = 60;        // 钩子起始点，相当于圆心        this.startX = game.canvasWidth / 2;        this.startY = 30;        // 钩子初始旋转角度值，即默认左边开始荡        this.rotateDeg = -this.rotateDegMax;        // 钩子方向值的控制 +1 -1代表不同的方向，每达到80或-80的时候转变方向        this.rotateZhengfu = -1;        // 钩子终点位置        this.endX = 0; // endX一直都是不变的，因为钩子的荡漾动作是旋转得到的         this.endY = this.gouziLong;        // 钩子图片参数        this.gouziW = 36;        this.gouziH = 28;        // 托管到game上        game.gouzi = this;    &#125;    Gouzi.prototype.render = function () &#123;        game.ctx.save();        game.ctx.beginPath();        game.ctx.lineWidth = 4;        game.ctx.lineCap = &#39;round&#39;;        game.ctx.translate(this.startX, this.startY);        game.ctx.rotate(this.rotateDeg * -DEG); // -DEG表示逆时针旋转        game.ctx.moveTo(0, 0);        game.ctx.lineTo(this.endX, this.endY);        game.ctx.stroke();        game.ctx.drawImage(game.R.zhuazi, 0, 0, 45, 35, this.endX - this.gouziW / 2, this.endY, this.gouziW, this.gouziH);        game.ctx.restore();    &#125;    Gouzi.prototype.update = function () &#123;        let endX;        switch (this.status) &#123;            case &#39;pending&#39;:                if (Math.abs(this.rotateDeg) == this.rotateDegMax) &#123;                    this.rotateZhengfu = -this.rotateZhengfu;                &#125;                this.rotateDeg += 1 * this.rotateZhengfu;                break;            case &#39;down&#39;:                // 如何判断该不该收钩子呢？                // 第1种是钩子抓到了就收钩子（通过endY + rotateDeg + sin公式计算出endX）                this.endY += 3;                endX = this.startX + (this.endY * Math.sin(this.rotateDeg * DEG));                let wawaIndex = game.wawaArr.findIndex(d =&gt; (d.y - d.h) &lt; this.endY &amp;&amp; this.endY &lt; d.y &amp;&amp; d.x &lt; endX &amp;&amp; endX &lt; (d.x + d.w));                if (wawaIndex != -1) &#123;                    // 移除娃娃                    game.wawaArr.splice(wawaIndex, 1);                    // 如果全被抓光了就end游戏                    if (game.wawaArr.length == 0) &#123;                        game.end();                    &#125;                    this.status = &#39;up&#39;;                &#125;                // 第2种是钩子长到最长距离然后开始收钩子                else if (this.endY &gt;= game.canvasHeight - this.startY - this.gouziH) &#123;                    this.status = &#39;up&#39;;                &#125;                break;            case &#39;up&#39;:                this.endY -= 3;                if (this.endY &lt;= this.gouziLong) &#123;                    this.endY = this.gouziLong;                    this.status = &#39;pending&#39;;                &#125;                break;            default:                return;        &#125;    &#125;&#125;)()</code></pre><h4 id="Wawa-js"><a href="#Wawa-js" class="headerlink" title="Wawa.js"></a>Wawa.js</h4><pre><code class="js">!(function () &#123;    // 借助工具http://www.spritecow.com/来获得定位，需要微调一下    var WawaImagePositionMap = [        &#123;            x: 0,            y: 96        &#125;,        &#123;            x: 2,            y: 129        &#125;,        &#123;            x: 3,            y: 168        &#125;,        &#123;            x: 33,            y: 96        &#125;,        &#123;            x: 36,            y: 132        &#125;,        &#123;            x: 37,            y: 168        &#125;,        &#123;            x: 65,            y: 98        &#125;,        &#123;            x: 100,            y: 97        &#125;,    ];    var Wawa = window.Wawa = function () &#123;        // 宽高        this.w = 32;        this.h = 32;        // 娃娃图片        let randomImage = WawaImagePositionMap[parseInt(Math.random() * WawaImagePositionMap.length)];        this.imageX = randomImage.x;        this.imageY = randomImage.y;        // 随机出现位置        this.x = Math.random() * game.canvasWidth;        this.y = Math.random() * (game.canvasHeight - game.safeTopHeight - this.h) + game.safeTopHeight;        // 托管到game上        game.wawaArr.push(this);    &#125;    Wawa.prototype.render = function () &#123;        game.ctx.drawImage(game.R.wawa, this.imageX, this.imageY, this.w, this.h, this.x, this.y, this.w, this.h);    &#125;    Wawa.prototype.update = function () &#123;        this.x += 0.5;        if (this.x &gt; game.canvasWidth) &#123;            this.x = -this.w;        &#125;    &#125;&#125;)()</code></pre><h4 id="R-json"><a href="#R-json" class="headerlink" title="R.json"></a>R.json</h4><pre><code class="json">[    &#123;        &quot;name&quot;: &quot;wawa&quot;,        &quot;img&quot;: &quot;./images/wawa.png&quot;    &#125;,    &#123;        &quot;name&quot;: &quot;zhuazi&quot;,        &quot;img&quot;: &quot;./images/zhuazi.png&quot;    &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Canvas </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas之全屏气泡</title>
      <link href="/2022/10/19/canvas-qipao/"/>
      <url>/2022/10/19/canvas-qipao/</url>
      
        <content type="html"><![CDATA[<h3 id="Canvas之全屏气泡"><a href="#Canvas之全屏气泡" class="headerlink" title="Canvas之全屏气泡"></a>Canvas之全屏气泡</h3><h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p><a href="https://postimg.cc/LqtCKYqQ"><img src="https://i.postimg.cc/6QSDZCBK/qipao-xiaoguo.gif" alt="qipao-xiaoguo.gif"></a></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;全屏气泡&lt;/title&gt;    &lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        html,        body &#123;            height: 100%;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;    if (canvas.getContext) &#123;        canvas.width = document.documentElement.clientWidth        canvas.height = document.documentElement.clientHeight        canvas.style.backgroundColor = &#39;white&#39;        const ctx = canvas.getContext(&#39;2d&#39;)        // 声明变量        let radius = 20,            r,            g,            b,            a,            x,            y,            arr = [],            temp = [];                // 先画5个气泡        for (let i = 0; i &lt; 5; i++) &#123;            createPop()        &#125;        // 监听点击事件        canvas.addEventListener(&#39;click&#39;, event =&gt; &#123;            console.log(&quot;点击了canvas：&quot;, event);            x = event.offsetX            y = event.offsetY            radius = 5            createPop(x, y, radius)        &#125;)        // 定时刷新canvas        setInterval(() =&gt; &#123;            ctx.clearRect(0, 0, canvas.width, canvas.height)            arr.forEach((item, index) =&gt; &#123;                if (item.a &lt;= 0) &#123;                    temp.push(index)                &#125; else &#123;                    item.radius += 0.5                    item.a -= 0.005                &#125;                drawPop(item.radius, item.r, item.g, item.b, item.a, item.x, item.y)            &#125;)            arr = arr.filter(item =&gt; &#123;                return item.a &gt; 0            &#125;)        &#125;, 1000 / 60);        // 定时添加新的气泡        setInterval(() =&gt; &#123;            createPop()        &#125;, 500);        // 画气泡        function drawPop(radius, r, g, b, a, x, y) &#123;            ctx.beginPath()            ctx.arc(x, y, radius, 0, 2 * Math.PI)            ctx.fillStyle = `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,$&#123;a&#125;)`            ctx.fill()        &#125;        // 气泡数据        function createPop(x, y, radius) &#123;            r = arcRandomColor()            g = arcRandomColor()            b = arcRandomColor()            radius = radius || Math.ceil(Math.random() * 10)            x = x || Math.ceil(Math.random() * canvas.width)            y = y || Math.ceil(Math.random() * canvas.height)            a = 1            const temp = &#123;                r,                g,                b,                a,                x,                y,                radius            &#125;            arr.push(temp)        &#125;        // 随机数据        function arcRandomColor() &#123;            return Math.ceil(Math.random() * 254)        &#125;    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Canvas </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canvas之钓娃娃GameDemo</title>
      <link href="/2022/10/18/canvas-diaoWawa/"/>
      <url>/2022/10/18/canvas-diaoWawa/</url>
      
        <content type="html"><![CDATA[<h3 id="Canvas之钓娃娃GameDemo"><a href="#Canvas之钓娃娃GameDemo" class="headerlink" title="Canvas之钓娃娃GameDemo"></a>Canvas之钓娃娃GameDemo</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>整个Demo，其实只是实现基本游戏逻辑，有些细节可继续优化，但是没有那么多空余时间了…</p><p>可谓是简版中的简版之黄金矿工 hhh…</p><p>先上个预览gif，再贴个代码…</p><p>可以上码云上看看: <a href="https://gitee.com/shaoyunfeng793/diao-wawa">https://gitee.com/shaoyunfeng793/diao-wawa</a></p><h4 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h4><p><a href="https://postimg.cc/SJ0fr04G"><img src="https://i.postimg.cc/yYxp7Br2/diaowawa.gif" alt="diaowawa.gif"></a></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Canvas之钓娃娃GameDemo&lt;/title&gt;    &lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        .container &#123;            width: 100vw;            height: 100vh;            background-color: #333;            display: flex;            justify-content: center;            align-items: center;        &#125;        #canvas &#123;            display: block;            background-color: bisque;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./game.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./wawa.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./gouzi.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var game = new Game(&#123;        dom: &#39;#canvas&#39;,        onClick: function () &#123;            if (game.gouzi.status == &#39;pending&#39;) &#123;                game.gouzi.status = &#39;down&#39;;            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="Game-js"><a href="#Game-js" class="headerlink" title="Game.js"></a>Game.js</h4><pre><code class="js">!(function () &#123;    var Game = window.Game = function (&#123;        dom,        onClick = function () &#123; &#125;,    &#125;) &#123;        this.canvas = document.querySelector(dom);        this.ctx = this.canvas.getContext(&quot;2d&quot;);        // 资源管理器        this.R = &#123;&#125;;        // 渲染定时器        this.renderTimer = null;        // 娃娃数组        this.wawaArr = [];        // 钩子实例        this.gouzi = null;        // 安全域        this.safeTopHeight = 200;        // 宽高        this.canvasWidth = this.canvas.width;        this.canvasHeight = this.canvas.height;        // 游戏初始化        this.init();        // 监听点击        this.canvas.addEventListener(&quot;click&quot;, onClick)    &#125;    Game.prototype.init = function () &#123;        console.log(&quot;游戏初始化&quot;);        let xhr = new XMLHttpRequest();        let self = this;        let loadCount = 0;        xhr.onreadystatechange = function () &#123;            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;                let data = JSON.parse(xhr.responseText);                for (let i = 0; i &lt; data.length; i++) &#123;                    self.R[data[i].name] = new Image();                    self.R[data[i].name].src = data[i].img;                    self.R[data[i].name].onload = function () &#123;                        loadCount++;                        self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);                        self.ctx.save()                        self.ctx.font = &quot;20px 微软雅黑&quot;;                        self.ctx.textAlign = &quot;center&quot;;                        self.ctx.fillText(`正在加载资源($&#123;loadCount&#125;/$&#123;data.length&#125;)...`, self.canvas.width * 0.5, self.canvas.height * 0.5);                        self.ctx.restore()                        if (loadCount == data.length) &#123;                            setTimeout(() =&gt; &#123;                                // 创建钩子                                new Gouzi();                                // 创建娃娃                                new Array(5).fill(1).forEach(() =&gt; &#123;                                    new Wawa();                                &#125;);                                self.start();                            &#125;, 1000)                        &#125;                    &#125;                &#125;            &#125;        &#125;        xhr.open(&quot;get&quot;, &quot;R.json&quot;, true);        xhr.send();    &#125;    Game.prototype.start = function () &#123;        let frame = 0;        this.renderTimer = setInterval(() =&gt; &#123;            frame++;            // 清屏            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);            // 画帧数            this.ctx.font = &quot;10px 微软雅黑&quot;;            this.ctx.fillStyle = &quot;red&quot;;            this.ctx.fillText(`Frame:$&#123;frame&#125;`, 10, 20);            // 画勾子            if (this.gouzi &amp;&amp; this.gouzi.constructor === Gouzi) &#123;                this.gouzi.render();                this.gouzi.update();            &#125;            // 画娃娃            this.wawaArr.forEach(function (wawa) &#123;                wawa.render();                wawa.update();            &#125;)        &#125;, 1000 / 60)    &#125;    Game.prototype.end = function () &#123;        clearInterval(this.renderTimer);        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);        this.ctx.font = &quot;30px bold 微软雅黑&quot;;        this.ctx.textAlign = &quot;center&quot;;        this.ctx.fillStyle = &quot;red&quot;;        this.ctx.fillText(`You Win！`, this.canvas.width / 2, this.canvas.height / 2);    &#125;&#125;)()</code></pre><h4 id="Gouzi-js"><a href="#Gouzi-js" class="headerlink" title="Gouzi.js"></a>Gouzi.js</h4><pre><code class="js">!(function () &#123;    const DEG = Math.PI / 180;    var Gouzi = window.Gouzi = function () &#123;        if (game.gouzi) &#123;            return game.gouzi        &#125;        // 钩子状态: pending：等待； down: 出钩 up: 收钩        this.status = &#39;pending&#39;;        // 钩子初始长度        this.rotateDegMax = 80;        this.gouziLong = 60;        // 钩子起始点，相当于圆心        this.startX = game.canvasWidth / 2;        this.startY = 30;        // 钩子初始旋转角度值，即默认左边开始荡        this.rotateDeg = -this.rotateDegMax;        // 钩子方向值的控制 +1 -1代表不同的方向，每达到80或-80的时候转变方向        this.rotateZhengfu = -1;        // 钩子终点位置        this.endX = 0; // endX一直都是不变的，因为钩子的荡漾动作是旋转得到的         this.endY = this.gouziLong;        // 钩子图片参数        this.gouziW = 36;        this.gouziH = 28;        // 托管到game上        game.gouzi = this;    &#125;    Gouzi.prototype.render = function () &#123;        game.ctx.save();        game.ctx.beginPath();        game.ctx.lineWidth = 4;        game.ctx.lineCap = &#39;round&#39;;        game.ctx.translate(this.startX, this.startY);        game.ctx.rotate(this.rotateDeg * -DEG); // -DEG表示逆时针旋转        game.ctx.moveTo(0, 0);        game.ctx.lineTo(this.endX, this.endY);        game.ctx.stroke();        game.ctx.drawImage(game.R.zhuazi, 0, 0, 45, 35, this.endX - this.gouziW / 2, this.endY, this.gouziW, this.gouziH);        game.ctx.restore();    &#125;    Gouzi.prototype.update = function () &#123;        let endX;        switch (this.status) &#123;            case &#39;pending&#39;:                if (Math.abs(this.rotateDeg) == this.rotateDegMax) &#123;                    this.rotateZhengfu = -this.rotateZhengfu;                &#125;                this.rotateDeg += 1 * this.rotateZhengfu;                break;            case &#39;down&#39;:                // 如何判断该不该收钩子呢？                // 第1种是钩子抓到了就收钩子（通过endY + rotateDeg + sin公式计算出endX）                this.endY += 3;                endX = this.startX + (this.endY * Math.sin(this.rotateDeg * DEG));                let wawaIndex = game.wawaArr.findIndex(d =&gt; (d.y - d.h) &lt; this.endY &amp;&amp; this.endY &lt; d.y &amp;&amp; d.x &lt; endX &amp;&amp; endX &lt; (d.x + d.w));                if (wawaIndex != -1) &#123;                    // 移除娃娃                    game.wawaArr.splice(wawaIndex, 1);                    // 如果全被抓光了就end游戏                    if (game.wawaArr.length == 0) &#123;                        game.end();                    &#125;                    this.status = &#39;up&#39;;                &#125;                // 第2种是钩子长到最长距离然后开始收钩子                else if (this.endY &gt;= game.canvasHeight - this.startY - this.gouziH) &#123;                    this.status = &#39;up&#39;;                &#125;                break;            case &#39;up&#39;:                this.endY -= 3;                if (this.endY &lt;= this.gouziLong) &#123;                    this.endY = this.gouziLong;                    this.status = &#39;pending&#39;;                &#125;                break;            default:                return;        &#125;    &#125;&#125;)()</code></pre><h4 id="Wawa-js"><a href="#Wawa-js" class="headerlink" title="Wawa.js"></a>Wawa.js</h4><pre><code class="js">!(function () &#123;    // 借助工具http://www.spritecow.com/来获得定位，需要微调一下    var WawaImagePositionMap = [        &#123;            x: 0,            y: 96        &#125;,        &#123;            x: 2,            y: 129        &#125;,        &#123;            x: 3,            y: 168        &#125;,        &#123;            x: 33,            y: 96        &#125;,        &#123;            x: 36,            y: 132        &#125;,        &#123;            x: 37,            y: 168        &#125;,        &#123;            x: 65,            y: 98        &#125;,        &#123;            x: 100,            y: 97        &#125;,    ];    var Wawa = window.Wawa = function () &#123;        // 宽高        this.w = 32;        this.h = 32;        // 娃娃图片        let randomImage = WawaImagePositionMap[parseInt(Math.random() * WawaImagePositionMap.length)];        this.imageX = randomImage.x;        this.imageY = randomImage.y;        // 随机出现位置        this.x = Math.random() * game.canvasWidth;        this.y = Math.random() * (game.canvasHeight - game.safeTopHeight - this.h) + game.safeTopHeight;        // 托管到game上        game.wawaArr.push(this);    &#125;    Wawa.prototype.render = function () &#123;        game.ctx.drawImage(game.R.wawa, this.imageX, this.imageY, this.w, this.h, this.x, this.y, this.w, this.h);    &#125;    Wawa.prototype.update = function () &#123;        this.x += 0.5;        if (this.x &gt; game.canvasWidth) &#123;            this.x = -this.w;        &#125;    &#125;&#125;)()</code></pre><h4 id="R-json"><a href="#R-json" class="headerlink" title="R.json"></a>R.json</h4><pre><code class="json">[    &#123;        &quot;name&quot;: &quot;wawa&quot;,        &quot;img&quot;: &quot;./images/wawa.png&quot;    &#125;,    &#123;        &quot;name&quot;: &quot;zhuazi&quot;,        &quot;img&quot;: &quot;./images/zhuazi.png&quot;    &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Canvas </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue之优雅的构建自己的组件库</title>
      <link href="/2022/10/15/vue-myselfCpns/"/>
      <url>/2022/10/15/vue-myselfCpns/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue之优雅的构建自己的组件库（Vue3）"><a href="#Vue之优雅的构建自己的组件库（Vue3）" class="headerlink" title="Vue之优雅的构建自己的组件库（Vue3）"></a>Vue之优雅的构建自己的组件库（Vue3）</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><em>现在市面上的组件库五花八门，但是又大同小异，现在就来看看如何较为优雅的开发自己的一套组件库，该篇写的组件都较为简单，组件复杂度可以说完全没有，但是主要想讲的是整套组件开发的大致结构</em></p><h4 id="组件库目录结构"><a href="#组件库目录结构" class="headerlink" title="组件库目录结构"></a>组件库目录结构</h4><p><img src="https://i.postimg.cc/1tp4dfF6/myself-Cpns-mulu.jpg" alt="目录结构"></p><p>把所有组件以文件夹的方式都放在<strong>src</strong>目录里，每个文件夹内都包含一<em>index.js</em>，和<em>index.css</em>，还有可能包括渲染组件的<code>.js</code>或者<code>.vue</code>文件</p><p><em>解释下每个文件的作用: 以<strong>button</strong>为例</em></p><h5 id="button-js"><a href="#button-js" class="headerlink" title="button.js"></a>button.js</h5><p>通过<code>h函数</code>来渲染出组件，当然也可以写成<code>.vue</code>的单文件形式</p><pre><code class="js">// vue3 通过import拿到 h函数import &#123; h &#125; from &#39;vue&#39;export default &#123;    name: &#39;button&#39;, // 用来注册组件名    props: &#123;        color: &#123;            type: String,            default: &#39;aqua&#39;        &#125;,        size: &#123;            type: String,            default: &#39;medium&#39;        &#125;    &#125;,    render(&#123; color, size &#125;) &#123;        return h(&#39;div&#39;, &#123; class: `yf-button yf-button--$&#123;size&#125;`, style: `background-color: $&#123;color&#125;` &#125;, [this.$slots.default ? this.$slots.default() : &#39;按钮&#39;])    &#125;&#125;</code></pre><h5 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h5><pre><code class="js">import Button from &quot;./button.js&quot;;// 在单个组件被使用时，即被vue.use()的时候直接注册成全局组件Button.install = function (app) &#123;    app.component(Button.name, Button);&#125;;export default Button</code></pre><h5 id="index-css"><a href="#index-css" class="headerlink" title="index.css"></a>index.css</h5><pre><code class="css">.yf-button &#123;    display: inline-block;    margin: 10px;    border-radius: 5px;    padding: 8px 15px;    background-color: aqua;    color: #fff;    cursor: pointer;&#125;.yf-button--large &#123;    padding: 10px 20px;&#125;.yf-button--medium &#123;    padding: 8px 15px;&#125;.yf-button--small &#123;    padding: 4px 8px;&#125;.yf-button:active &#123;    filter: grayscale(0.3);&#125;</code></pre><h4 id="所有组件的总入口文件"><a href="#所有组件的总入口文件" class="headerlink" title="所有组件的总入口文件"></a>所有组件的总入口文件</h4><p>与<em>src目录</em>同级的2个文件：<strong>index.js</strong>、<strong>index.css</strong>是所有组件的总入口</p><h5 id="总入口index-js"><a href="#总入口index-js" class="headerlink" title="总入口index.js"></a>总入口index.js</h5><pre><code class="js">import button from &#39;./src/button/index.js&#39;import loading from &#39;./src/loading/index.js&#39;import splitline from &#39;./src/splitline/index.js&#39;import ul from &#39;./src/ul/index.js&#39;import li from &#39;./src/li/index.js&#39;import Switch from &#39;./src/switch/index.js&#39;const components = [    button,    loading,    splitline,    ul,    li,    Switch];export default &#123;    install(app) &#123;        // 通过异步方式直接引入总入口index.css文件        import(&#39;./index.css&#39;);        // 遍历注册全局组件        components.forEach(cpn =&gt; &#123;            app.component(`yf-$&#123;cpn.name&#125;`, cpn)        &#125;)    &#125;,    button,    loading,    splitline,    ul,    li,    Switch&#125;</code></pre><h5 id="总入口index-css"><a href="#总入口index-css" class="headerlink" title="总入口index.css"></a>总入口index.css</h5><pre><code class="css">@import &#39;./src/button/index.css&#39;;@import &#39;./src/loading/index.css&#39;;@import &#39;./src/splitline/index.css&#39;;@import &#39;./src/ul/index.css&#39;;@import &#39;./src/message/index.css&#39;;@import &#39;./src/switch/index.css&#39;;</code></pre><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>在vue项目的<code>main.js</code>中，键入代码（以<em>vite+vue3</em>项目为例）</p><pre><code class="js">import &#123; createApp &#125; from &#39;vue&#39;import &#39;./style.css&#39;import App from &#39;./App.vue&#39;import router from &#39;./router/index.js&#39;// 导入我的组件库  注意：一定得导！得导！导！import yfCpns from &#39;./yf-cpns/index.js&#39;// 导入自己写的message插件， 通过this.$message来提示信息import message from &#39;./yf-cpns/src/message&#39;const app = createApp(App)// 注册我的组件库  注意：一定得注！得注！注！app.use(yfCpns)app.use(message)app.use(router).mount(&#39;#app&#39;)</code></pre><p>在某个页面<code>.vue</code>文件中直接使用，代码如下</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;yf-button color=&quot;pink&quot; size=&quot;small&quot;&gt;小按钮&lt;/yf-button&gt;    &lt;yf-button&gt;按钮&lt;/yf-button&gt;    &lt;yf-button color=&quot;greenyellow&quot; size=&quot;large&quot;&gt;大按钮&lt;/yf-button&gt;    &lt;yf-splitline /&gt;    &lt;yf-loading color=&quot;pink&quot; size=&quot;small&quot;&gt;&lt;/yf-loading&gt;    &lt;yf-loading&gt;&lt;/yf-loading&gt;    &lt;yf-loading color=&quot;greenyellow&quot; size=&quot;large&quot;&gt;&lt;/yf-loading&gt;    &lt;yf-splitline /&gt;    &lt;yf-ul&gt;      &lt;yf-li&gt;看电影&lt;/yf-li&gt;      &lt;yf-li&gt;听音乐&lt;/yf-li&gt;      &lt;yf-li&gt;打游戏&lt;/yf-li&gt;      &lt;yf-li&gt;做爱做的事&lt;/yf-li&gt;    &lt;/yf-ul&gt;    &lt;yf-ul sign=&quot;🎃&quot;&gt;      &lt;yf-li&gt;看电影&lt;/yf-li&gt;      &lt;yf-li&gt;听音乐&lt;/yf-li&gt;      &lt;yf-li&gt;打游戏&lt;/yf-li&gt;      &lt;yf-li&gt;做爱做的事&lt;/yf-li&gt;    &lt;/yf-ul&gt;    &lt;yf-ul sign=&quot;😊&quot;&gt;      &lt;yf-li&gt;看电影&lt;/yf-li&gt;      &lt;yf-li&gt;听音乐&lt;/yf-li&gt;      &lt;yf-li&gt;打游戏&lt;/yf-li&gt;      &lt;yf-li&gt;做爱做的事&lt;/yf-li&gt;    &lt;/yf-ul&gt;    &lt;yf-splitline /&gt;    &lt;yf-button color=&quot;greenyellow&quot; @click=&quot;showSuccess&quot;&gt;成功提示&lt;/yf-button&gt;    &lt;yf-button @click=&quot;showNormal&quot;&gt;普通提示&lt;/yf-button&gt;    &lt;yf-button color=&quot;red&quot; @click=&quot;showError&quot;&gt;失败提示&lt;/yf-button&gt;    &lt;yf-splitline /&gt;    &lt;yf-switch v-model=&quot;checkValue&quot;&gt;&lt;/yf-switch&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      checkValue: false    &#125;;  &#125;,  methods: &#123;    showNormal() &#123;      this.$message(&#123;        content: &quot;普通信息&quot;      &#125;);    &#125;,    showSuccess() &#123;      this.$message.success(&quot;成功信息&quot;);    &#125;,    showError() &#123;      this.$message.error(&quot;错误信息&quot;);    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://i.postimg.cc/J4RH9cPh/myself-Cpns-xiaoguo.gif" alt="目录结构"></p><p>码云地址：<a href="https://gitee.com/shaoyunfeng793/yf-cpns">https://gitee.com/shaoyunfeng793/yf-cpns</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些可能用到的工具网站</title>
      <link href="/2022/10/13/utils-webSite/"/>
      <url>/2022/10/13/utils-webSite/</url>
      
        <content type="html"><![CDATA[<h3 id="一些可能用到的工具网站"><a href="#一些可能用到的工具网站" class="headerlink" title="一些可能用到的工具网站"></a>一些可能用到的工具网站</h3><h4 id="1-去除多余CSS"><a href="#1-去除多余CSS" class="headerlink" title="1.去除多余CSS"></a>1.去除多余CSS</h4><p>注入html代码和css完成去除多余css<br>地址： <a href="https://uncss-online.com/">https://uncss-online.com/</a></p><h4 id="2-CSS-sprite图"><a href="#2-CSS-sprite图" class="headerlink" title="2.CSS sprite图"></a>2.CSS sprite图</h4><p>上传若干图片，帮你生成雪碧图，还可以帮助你直接定位到相应图标的css样式<br>地址： <a href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a>; <a href="http://www.spritecow.com/">http://www.spritecow.com/</a>;</p><h4 id="3-图片压缩TinyPng"><a href="#3-图片压缩TinyPng" class="headerlink" title="3.图片压缩TinyPng"></a>3.图片压缩TinyPng</h4><p>一个很强大且免费的压缩网站<br>地址： <a href="https://tinypng.com/">https://tinypng.com</a></p><h4 id="4-css动画"><a href="#4-css动画" class="headerlink" title="4.css动画"></a>4.css动画</h4><p>有很多css动画样式，可以直接查看效果<br>地址： <a href="https://animate.style/">https://animate.style/</a></p><h4 id="5-css渐变颜色"><a href="#5-css渐变颜色" class="headerlink" title="5.css渐变颜色"></a>5.css渐变颜色</h4><p>有很多好看的渐变颜色<br>地址： <a href="https://webkul.github.io/coolhue/">https://webkul.github.io/coolhue/</a></p><h4 id="6-删除背景"><a href="#6-删除背景" class="headerlink" title="6.删除背景"></a>6.删除背景</h4><p>一个扣除背景的网站<br>地址： <a href="https://www.remove.bg/">https://www.remove.bg/</a></p><h4 id="7-转换文件格式"><a href="#7-转换文件格式" class="headerlink" title="7.转换文件格式"></a>7.转换文件格式</h4><p>一个可以免费转换文件格式的网站，（有限制）<br>地址： <a href="https://convertio.co/zh/">https://convertio.co/zh/</a></p><h4 id="8-emoji表情符号"><a href="#8-emoji表情符号" class="headerlink" title="8.emoji表情符号"></a>8.emoji表情符号</h4><p>一个emoji表情符号大全的网站<br>地址： <a href="https://emojipedia.org/">https://emojipedia.org/</a></p><h4 id="9-图片托管"><a href="#9-图片托管" class="headerlink" title="9.图片托管"></a>9.图片托管</h4><p>免费图片托管的网站，可以把博客图片都托管到这<br>地址： <a href="https://postimages.org/">https://postimages.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> Utils </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS技巧之DIV保持长宽比</title>
      <link href="/2022/10/13/css-aspectRatioDiv/"/>
      <url>/2022/10/13/css-aspectRatioDiv/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS技巧之DIV保持长宽比"><a href="#CSS技巧之DIV保持长宽比" class="headerlink" title="CSS技巧之DIV保持长宽比"></a>CSS技巧之DIV保持长宽比</h3><p><strong>ps:</strong> <em>我们都知道在前端开发中经常遇到需要保持一个元素的长宽比，最常见的就是我们的Img元素，但是除了img、vidoe这种可替换元素元素具有长宽比的特性，那么其它元素如果保持长宽比呢，这给我们的开发带来了许多不便利…</em></p><h4 id="方式1-padding-top-hack"><a href="#方式1-padding-top-hack" class="headerlink" title="方式1 padding-top-hack"></a>方式1 padding-top-hack</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;style&gt;        *&#123;            padding: 0;            margin: 0;        &#125;        .outer &#123;            position: relative;            height: 0;            padding-top: 56.25%;        &#125;        .inner &#123;            background-color: skyblue;            position: absolute;            top: 0;            right: 0;            bottom: 0;            left: 0;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;    &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="方式2-aspect-ratio"><a href="#方式2-aspect-ratio" class="headerlink" title="方式2 aspect-ratio"></a>方式2 aspect-ratio</h4><p><em>该方式存在兼容性问题，想要知道兼容性可在<strong>Can i use</strong>上查看</em></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;style&gt;        *&#123;            padding: 0;            margin: 0;        &#125;        .inner &#123;            background-color: skyblue;            width: 50%;            aspect-ratio: auto 2 / 1; /* 只需这一行 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端H5开发技巧</title>
      <link href="/2022/10/06/html-mobileH5/"/>
      <url>/2022/10/06/html-mobileH5/</url>
      
        <content type="html"><![CDATA[<h3 id="移动端H5开发技巧"><a href="#移动端H5开发技巧" class="headerlink" title="移动端H5开发技巧"></a>移动端H5开发技巧</h3><p><strong>ps:</strong> <em>h5在移动端开发上各个浏览器不同系统上都有太多的差异，整个移动端阶段都是遇坑填坑的学习过程，以下h5移动端开发技巧供君填坑…</em></p><h4 id="html方向"><a href="#html方向" class="headerlink" title="html方向"></a>html方向</h4><h5 id="调用系统功能"><a href="#调用系统功能" class="headerlink" title="调用系统功能"></a>调用系统功能</h5><p>使用<code>&lt;a&gt;</code>能快速调用移动设备的<code>电话/短信/邮件</code>三大通讯功能，使用<code>&lt;input&gt;</code>能快速调用移动设备的的图库&#x2F;文件。</p><p>这些功能方便了页面与系统的交互，关键在于调用格式一定要准确，否则会被移动端浏览器忽略。</p><pre><code class="html">    &lt;!-- 拨打电话 --&gt;    &lt;a href=&quot;tel:10086&quot;&gt;拨打电话给10086小姐姐&lt;/a&gt;    &lt;!-- 发送短信 --&gt;    &lt;a href=&quot;sms:10086&quot;&gt;发送短信给10086小姐姐&lt;/a&gt;    &lt;!-- 发送邮件 --&gt;    &lt;a href=&quot;mailto:young.joway@aliyun.com&quot;&gt;发送邮件给JowayYoung&lt;/a&gt;    &lt;!-- 选择照片或拍摄照片 --&gt;    &lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt;    &lt;!-- 选择视频或拍摄视频 --&gt;    &lt;input type=&quot;file&quot; accept=&quot;video/*&quot;&gt;    &lt;!-- 多选文件 --&gt;    &lt;input type=&quot;file&quot; multiple&gt;</code></pre><h5 id="忽略自动识别"><a href="#忽略自动识别" class="headerlink" title="忽略自动识别"></a>忽略自动识别</h5><p>有些移动端浏览器会自动将数字字母符号识别为<code>电话/邮箱</code>并将其渲染成上述 <strong>「调用系统功能」</strong> 里的<code>&lt;a&gt;</code>。虽然很方便却有可能违背需求。</p><pre><code class="html">    &lt;!-- 忽略自动识别电话 --&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;    &lt;!-- 忽略自动识别邮箱 --&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;    &lt;!-- 忽略自动识别电话和邮箱 --&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;&gt;</code></pre><h5 id="弹出数字键盘"><a href="#弹出数字键盘" class="headerlink" title="弹出数字键盘"></a>弹出数字键盘</h5><p>使用<code>&lt;input type=&quot;tel&quot;&gt;</code>弹起数字键盘会带上#和*，适合输入电话。推荐使用<code>&lt;input type=&quot;number&quot; pattern=&quot;\d*&quot;&gt;</code>弹起数字键盘，适合输入验证码等纯数字格式。</p><pre><code class="html">    &lt;!-- 纯数字带#和* --&gt;    &lt;input type=&quot;tel&quot;&gt;    &lt;!-- 纯数字 --&gt;    &lt;input type=&quot;number&quot; pattern=&quot;\d*&quot;&gt;</code></pre><h5 id="唤醒原生应用"><a href="#唤醒原生应用" class="headerlink" title="唤醒原生应用"></a>唤醒原生应用</h5><p>通过<code>location.href</code>与原生应用建立通讯渠道，这种页面与客户端的通讯方式称为 <strong>「URL Scheme」</strong>，其基本格式为<code>scheme://[path][?query]</code>，更多<code>URL Scheme</code>的详述请自行度娘。</p><ul><li><strong>「scheme」</strong>：应用标识，表示应用在系统里的唯一标识</li><li><strong>「path」</strong>：应用行为，表示应用某个页面或功能</li><li><strong>「query」</strong>：应用参数，表示应用页面或应用功能所需的条件参数</li></ul><p><code>URL Scheme</code>一般由前端与客户端共同协商。唤醒原生应用的前提是必须在移动设备里安装了该应用，有些移动端浏览器即使安装了该应用也无法唤醒原生应用，因为它认为<code>URL Scheme</code>是一种潜在的危险行为而禁用它，像<code>Safari</code>和<code>微信浏览器</code>。还好<code>微信浏览器</code>可开启白名单让<code>URL Scheme</code>有效。</p><pre><code class="html">    &lt;!-- 打开微信 --&gt;    &lt;a href=&quot;weixin://&quot;&gt;打开微信&lt;/a&gt;    &lt;!-- 打开支付宝 --&gt;    &lt;a href=&quot;alipays://&quot;&gt;打开支付宝&lt;/a&gt;    &lt;!-- 打开支付宝的扫一扫 --&gt;    &lt;a href=&quot;alipays://platformapi/startapp?saId=10000007&amp;qrcode=https://qr.alipay.com/bax02911brluc2xieoph6001&quot;&gt;打开支付宝的扫一扫&lt;/a&gt;    &lt;!-- 打开支付宝的蚂蚁森林 --&gt;    &lt;a href=&quot;alipays://platformapi/startapp?appId=60000002&quot;&gt;打开支付宝的蚂蚁森林&lt;/a&gt;    &lt;!-- 打开支付宝内置浏览器并跳到百度 --&gt;    &lt;a href=&quot;alipays://platformapi/startapp?appId=20000067&amp;url=https%3A%2F%2Fwww.baidu.com&quot;&gt;打开支付宝内置浏览器&lt;/a&gt;    </code></pre><h5 id="禁止页面缩放"><a href="#禁止页面缩放" class="headerlink" title="禁止页面缩放"></a>禁止页面缩放</h5><p>在智能手机的普及下，很多网站都具备桌面端和移动端两种浏览版本，因此无需双击缩放查看页面。禁止页面缩放可保障移动端浏览器能无遗漏地展现页面所有布局。</p><pre><code class="html">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1&quot;&gt;</code></pre><h5 id="禁止页面缓存"><a href="#禁止页面缓存" class="headerlink" title="禁止页面缓存"></a>禁止页面缓存</h5><p><strong>「Cache-Control」</strong>指定请求和响应遵循的缓存机制，不想使用浏览器缓存就直接禁止</p><pre><code class="html">    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt;</code></pre><h5 id="禁止字母大写"><a href="#禁止字母大写" class="headerlink" title="禁止字母大写"></a>禁止字母大写</h5><p>有时在输入框里输入文本会默认开启首字母大写纠正，就是输入首字母小写会被自动纠正成大写，特么的烦。直接声明<code>autocapitalize=off</code>关闭首字母大写功能和<code>autocorrect=off</code>关闭纠正功能</p><pre><code class="html">    &lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot;&gt;</code></pre><h5 id="针对Safari配置"><a href="#针对Safari配置" class="headerlink" title="针对Safari配置"></a>针对Safari配置</h5><pre><code class="html">    &lt;!-- 设置Safari全屏，在iOS7+无效 --&gt;    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;    &lt;!-- 改变Safari状态栏样式，可选default/black/black-translucent，需在上述全屏模式下才有效 --&gt;    &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;    &lt;!-- 添加页面启动占位图 --&gt;    &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;pig.jpg&quot; media=&quot;(device-width: 375px)&quot;&gt;    &lt;!-- 保存网站到桌面时添加图标 --&gt;    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;pig.jpg&quot;&gt;    &lt;!-- 保存网站到桌面时添加图标且清除默认光泽 --&gt;    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;pig.jpg&quot;&gt;</code></pre><h5 id="针对其他浏览器配置"><a href="#针对其他浏览器配置" class="headerlink" title="针对其他浏览器配置"></a>针对其他浏览器配置</h5><p>贴一些其他浏览器较零散且少用的配置，主要是常用的<code>QQ浏览器</code>、<code>UC浏览器</code>和<code>360浏览器</code>。<strong>但是</strong>，新版的<code>QQ浏览器</code>和<code>UC浏览器</code>已不支持以下<code>&lt;meta&gt;</code>声明了。</p><pre><code class="html">    &lt;!-- 强制QQ浏览器竖屏 --&gt;    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;    &lt;!-- 强制QQ浏览器全屏 --&gt;    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;    &lt;!-- 开启QQ浏览器应用模式 --&gt;    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;    &lt;!-- 强制UC浏览器竖屏 --&gt;    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;    &lt;!-- 强制UC浏览器全屏 --&gt;    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;    &lt;!-- 开启UC浏览器应用模式 --&gt;    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;    &lt;!-- 开启360浏览器极速模式 --&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></pre><h5 id="让-active有效，让-hover无效"><a href="#让-active有效，让-hover无效" class="headerlink" title="让:active有效，让:hover无效"></a>让:active有效，让:hover无效</h5><p>有些元素的<code>:active</code>可能会无效，而元素的<code>:hover</code>在点击后会一直处于点击状态，需点击其他位置才能解除点击状态。给<code>&lt;body&gt;</code>注册一个<strong>空</strong>的<code>touchstart</code>事件可将两种状态反转。</p><pre><code class="html">    &lt;body ontouchstart&gt;&lt;/body&gt;</code></pre><h4 id="css方向"><a href="#css方向" class="headerlink" title="css方向"></a>css方向</h4><h5 id="自动适应布局"><a href="#自动适应布局" class="headerlink" title="自动适应布局"></a>自动适应布局</h5><p>针对移动端，通常会结合JS依据屏幕宽度与设计图宽度的比例动态声明<code>&lt;html&gt;</code>的<code>font-size</code>，以<code>rem</code>为长度单位声明所有节点的几何属性，这样就能做到大部分移动设备的页面兼容，兼容出入较大的地方再通过媒体查询做特别处理。<br>通过rem布局比例设置成<code>1rem=100px</code>，即在设计图上<code>100px</code>长度在CSS代码上使用<code>1rem</code>表示。尽可能使用<strong>1rem&#x3D;100px</strong>的比例，因为响应式布局在pc端也需要响应，但是页面存在默认最小字号，所以尽可能放大<strong>html</strong>的<strong>font-size</strong>，即调大<strong>1rem和px的比例</strong>。</p><p>css方式</p><pre><code class="css">    html &#123;        font-size: calc(100vw / 7.5);    &#125;</code></pre><p>js方式</p><pre><code class="js">    function AutoResponse(width = 750) &#123;        const target = document.documentElement;        if (target.clientWidth &gt;= 600) &#123;            target.style.fontSize = &quot;80px&quot;;        &#125; else &#123;            target.style.fontSize = target.clientWidth / width * 100 + &quot;px&quot;;        &#125;    &#125;    AutoResponse();    window.addEventListener(&quot;resize&quot;, () =&gt; AutoResponse());</code></pre><p>若以<strong>iPad Pro</strong>分辨率<strong>1024px</strong>为移动端和桌面端的断点，还可结合媒体查询做断点处理。<strong>1024px</strong>以下使用<strong>rem布局</strong>，否则不使用<strong>rem布局</strong></p><pre><code class="css">    @media screen and (max-width: 1024px) &#123;        html &#123;            font-size: calc(100vw / 7.5);        &#125;    &#125;</code></pre><h5 id="自动适应背景"><a href="#自动适应背景" class="headerlink" title="自动适应背景"></a>自动适应背景</h5><p>使用<code>rem布局</code>声明一个元素背景，多数情况会将<code>background-size</code>声明为<code>cover</code>。可能在设计图对应分辨率的移动设备下，背景会完美贴合显示，但换到其他分辨率的移动设备下就会出现左右空出1px到npx的空隙。</p><p>此时将<code>background-size</code>声明为<code>100% 100%</code>，跟随width和height的变化而变化。反正width和height都是量好的实际尺寸。</p><pre><code class="css">    .elem &#123;        width: 1rem;        height: 1rem;        background: url(&quot;pig.jpg&quot;) no-repeat center/100% 100%;    &#125;</code></pre><h5 id="监听屏幕旋转"><a href="#监听屏幕旋转" class="headerlink" title="监听屏幕旋转"></a>监听屏幕旋转</h5><p>通过css的方式调整<strong>横屏</strong>、<strong>竖屏</strong>的样式</p><pre><code class="css">    /* 竖屏 */    @media all and (orientation: portrait) &#123;        /* 自定义样式 */    &#125;    /* 横屏 */    @media all and (orientation: landscape) &#123;        /* 自定义样式 */    &#125;</code></pre><h5 id="支持弹性滚动"><a href="#支持弹性滚动" class="headerlink" title="支持弹性滚动"></a>支持弹性滚动</h5><p>在苹果系统上非<code>&lt;body&gt;</code>元素的滚动操作可能会存在卡顿，但安卓系统不会出现该情况。通过声明<code>overflow-scrolling:touch</code>调用系统原生滚动事件优化<em>弹性滚动</em>，增加页面滚动的流畅度。</p><pre><code class="css">    body &#123;        -webkit-overflow-scrolling: touch;    &#125;    .elem &#123;        overflow: auto;    &#125;</code></pre><h5 id="禁止滚动传播"><a href="#禁止滚动传播" class="headerlink" title="禁止滚动传播"></a>禁止滚动传播</h5><p>与桌面端浏览器不一样，移动端浏览器有一个奇怪行为。当页面包含多个滚动区域时，滚完一个区域后若还存在滚动动量则会将这些剩余动量传播到下一个滚动区域，造成该区域也滚动起来。这种行为称为 <strong>「滚动传播」</strong>。</p><pre><code class="css">    .elem &#123;        overscroll-behavior: contain;    &#125;</code></pre><h5 id="禁止屏幕抖动"><a href="#禁止屏幕抖动" class="headerlink" title="禁止屏幕抖动"></a>禁止屏幕抖动</h5><p>对于一些突然出现滚动条的页面，可能会产生左右抖动的不良影响。在一个滚动容器里，打开弹窗就隐藏滚动条，关闭弹窗就显示滚动条，来回操作会让屏幕抖动起来。提前声明滚动容器的padding-right为滚动条宽度，就能有效消除这个不良影响。</p><p>每个移动端浏览器的滚动条宽度都有可能不一致，甚至不一定占位置，通过以下方式能间接计算出滚动条的宽度。100vw为视窗宽度，100%为滚动容器内容宽度，相减就是滚动条宽度，妥妥的动态计算。</p><pre><code class="css">    body &#123;        padding-right: calc(100vw - 100%);    &#125;</code></pre><h5 id="禁止长按操作"><a href="#禁止长按操作" class="headerlink" title="禁止长按操作"></a>禁止长按操作</h5><p>有时不想用户长按元素呼出菜单进行<strong>点链接、打电话、发邮件、保存图片或扫描二维码</strong>等操作，声明<code>touch-callout:none</code>禁止用户长按操作。</p><p>有时不想用户复制粘贴盗文案，声明<code>user-select:none</code>禁止用户长按操作和选择复制。</p><pre><code class="css">    .elem &#123;        /* pointer-events: none; */ /* 微信浏览器还需附加该属性才有效 */        user-select: none; /* 禁止长按选择文字 */        -webkit-touch-callout: none;    &#125;</code></pre><h5 id="禁止字体调整"><a href="#禁止字体调整" class="headerlink" title="禁止字体调整"></a>禁止字体调整</h5><p>旋转屏幕可能会改变字体大小，声明<code>text-size-adjust:100%</code>让字体大小保持不变。</p><pre><code class="css">   * &#123;        text-size-adjust: 100%;    &#125;</code></pre><h5 id="禁止动画闪屏"><a href="#禁止动画闪屏" class="headerlink" title="禁止动画闪屏"></a>禁止动画闪屏</h5><p>在移动设备上添加动画，多数情况会出现闪屏，给动画元素的父元素构造一个3D环境就能让动画稳定运行了。</p><pre><code class="css">   .elem &#123;        perspective: 1000;        backface-visibility: hidden;        transform-style: preserve-3d;    &#125;</code></pre><h5 id="美化表单外观"><a href="#美化表单外观" class="headerlink" title="美化表单外观"></a>美化表单外观</h5><pre><code class="css">    button,    input,    select,    textarea &#123;        appearance: none;        /* 自定义样式 */    &#125;</code></pre><h5 id="美化滚动占位"><a href="#美化滚动占位" class="headerlink" title="美化滚动占位"></a>美化滚动占位</h5><p>通过<code>::-webkit-scrollbar-*</code>美化滚动条</p><ul><li><strong>「::-webkit-scrollbar」</strong>：滚动条整体部分</li><li><strong>「::-webkit-scrollbar-track」</strong>：滚动条轨道部分</li><li><strong>「::-webkit-scrollbar-thumb」</strong>：滚动条滑块部分</li></ul><pre><code class="css">    ::-webkit-scrollbar &#123;        width: 6px;        height: 6px;        background-color: transparent;    &#125;    ::-webkit-scrollbar-track &#123;        background-color: transparent;    &#125;    ::-webkit-scrollbar-thumb &#123;        border-radius: 3px;        background-image: linear-gradient(135deg, #09f, #3c9);    &#125;</code></pre><h5 id="美化输入占位"><a href="#美化输入占位" class="headerlink" title="美化输入占位"></a>美化输入占位</h5><pre><code class="css">    input::-webkit-input-placeholder &#123;        color: #66f;    &#125;</code></pre><h5 id="对齐输入占位"><a href="#对齐输入占位" class="headerlink" title="对齐输入占位"></a>对齐输入占位</h5><p>有强迫症的同学总会觉得输入框文本位置整体偏上，感觉未居中心里就痒痒的。<strong>桌面端浏览器</strong>里声明<code>line-height</code>等于<code>height</code>就能解决，但<strong>移动端浏览器</strong>里还是未能解决，需将<code>line-height</code>声明为<code>normal</code>才行。</p><pre><code class="css">    input &#123;        line-height: normal;    &#125;</code></pre><h5 id="对齐下拉选项"><a href="#对齐下拉选项" class="headerlink" title="对齐下拉选项"></a>对齐下拉选项</h5><pre><code class="css">    select option &#123;        direction: rtl;    &#125;</code></pre><h5 id="描绘1px边框"><a href="#描绘1px边框" class="headerlink" title="描绘1px边框"></a>描绘1px边框</h5><pre><code class="css">    .elem &#123;        position: relative;        width: 200px;        height: 80px;        &amp;::after &#123;            position: absolute;            left: 0;            top: 0;            border: 1px solid #f66;            width: 200%;            height: 200%;            content: &quot;&quot;;            transform: scale(.5);            transform-origin: left top;        &#125;    &#125;</code></pre><h5 id="文本溢出省略"><a href="#文本溢出省略" class="headerlink" title="文本溢出省略"></a>文本溢出省略</h5><pre><code class="css">    .elem &#123;        width: 400px;        line-height: 30px;        font-size: 20px;        /* 单行溢出 */        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;         /* 多行溢出 */        display: -webkit-box;        overflow: hidden;        text-overflow: ellipsis;        -webkit-line-clamp: 3;        -webkit-box-orient: vertical;    &#125;</code></pre><h4 id="js方向"><a href="#js方向" class="headerlink" title="js方向"></a>js方向</h4><h5 id="往返刷新"><a href="#往返刷新" class="headerlink" title="往返刷新"></a>往返刷新</h5><p>点击移动端浏览器的前进按钮或后退按钮，有时不会自动执行旧页面的JS代码，这与往返缓存有关。这种情况在<strong>Safari</strong>上特别明显，简单概括就是往返页面无法刷新。</p><p><strong>「往返缓存」</strong>指浏览器为了在页面间执行前进后退操作时能拥有更流畅体验的一种策略，以下简称<strong>BFCache</strong>。该策略具体表现为：当用户前往新页面前将旧页面的DOM状态保存在<strong>BFCache</strong>里，当用户返回旧页面前将旧页面的DOM状态从<strong>BFCache</strong>里取出并加载。大部分移动端浏览器都会部署<strong>BFCache</strong>，可大大节省接口请求的时间和带宽。</p><p><code>pageshow</code>事件在每次页面加载时都会触发，无论是首次加载还是再次加载都会触发，这就是它与load事件的区别。<code>pageshow</code>事件暴露的<code>persisted</code>可判断页面是否从<strong>BFCache</strong>里取出。</p><pre><code class="js">    window.addEventListener(&quot;pageshow&quot;, e =&gt; e.persisted &amp;&amp; location.reload());</code></pre><h5 id="自动播放媒体"><a href="#自动播放媒体" class="headerlink" title="自动播放媒体"></a>自动播放媒体</h5><p>常见媒体元素包括音频<code>&lt;audio&gt;</code>和视频<code>&lt;video&gt;</code>，为了让用户得到更好的媒体播放体验与不盲目浪费用户流量，大部分移动端浏览器都明确规定不能自动播放媒体或默认屏蔽<code>autoplay</code>。为了能让媒体在页面加载完成后自动播放，只能显式声明播放。</p><pre><code class="js">    const audio = document.getElementById(&quot;audio&quot;);    const video = document.getElementById(&quot;video&quot;);    audio.play();    video.play();</code></pre><p>在苹果系统上明确规定用户交互操作开始后才能播放媒体，未得到用户响应会被<strong>Safari</strong>自动拦截，因此需监听用户首次触摸操作并触发媒体自动播放，而该监听仅此一次。</p><pre><code class="js">    document.body.addEventListener(&quot;touchstart&quot;, () =&gt; &#123;        // 执行上面媒体自动播放代码            &#125;, &#123; once: true &#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue性能优化方式</title>
      <link href="/2022/10/06/vue-optimizationCode/"/>
      <url>/2022/10/06/vue-optimizationCode/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue性能优化方式"><a href="#Vue性能优化方式" class="headerlink" title="Vue性能优化方式"></a>Vue性能优化方式</h3><p><strong>ps:</strong> <em>我们在使用 Vue 或其他框架的日常开发中，或多或少的都会遇到一些性能问题，尽管 Vue 内部已经帮助我们做了许多优化，但是还是有些问题是需要我们主动去避免的。我在我的日常开中，以及网上各种大佬的文章中总结了一些容易产生性能问题的场景以及针对这些问题优化的技巧，这篇文章就来探讨下，希望对你有所帮助。</em></p><h4 id="一、使用v-slot-slotName"><a href="#一、使用v-slot-slotName" class="headerlink" title="一、使用v-slot:slotName"></a>一、使用v-slot:slotName</h4><p><code>v-slot</code>是 2.6 新增的语法，具体可查看:Vue2.6，2.6 发布已经是快两年前的事情了，但是现在仍然有不少人仍然在使用<code>slot=&quot;slotName&quot;</code>这个语法。虽然这两个语法都能达到相同的效果，但是内部的逻辑确实不一样的，下面来看下这两种方式有什么不同之处。</p><p>我们先来看下这两种语法分别会被编译成什么：</p><h5 id="v-slot-slotName编译"><a href="#v-slot-slotName编译" class="headerlink" title="v-slot:slotName编译"></a>v-slot:slotName编译</h5><pre><code>    //编译前     &lt;child&gt;        &lt;template v-slot:name&gt;&#123;&#123;name&#125;&#125;&lt;/template&gt;    &lt;/child&gt;    // 编译后    function render() &#123;        with (this) &#123;            return _c(&#39;child&#39;, &#123;            scopedSlots: _u([                &#123;                key: &#39;name&#39;,                fn: function () &#123;                    return [_v(_s(name))]                &#125;,                proxy: true                &#125;            ])            &#125;)        &#125;    &#125;</code></pre><h5 id="slot-x3D-”slotName”编译"><a href="#slot-x3D-”slotName”编译" class="headerlink" title="slot&#x3D;”slotName”编译"></a>slot&#x3D;”slotName”编译</h5><pre><code>    //编译前     &lt;child&gt;        &lt;template v-slot:name&gt;&#123;&#123;name&#125;&#125;&lt;/template&gt;    &lt;/child&gt;    // 编译后    function render() &#123;        with (this) &#123;            return _c(            &#39;child&#39;,            [                _c(                &#39;template&#39;,                &#123;                    slot: &#39;name&#39;                &#125;,                [_v(_s(name))]                )            ],            )        &#125;    &#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过编译后的代码可以发现，<strong>旧的写法是将插槽内容作为 children 渲染的，会在父组件的渲染函数中创建，插槽内容的依赖会被父组件收集（name 的 dep 收集到父组件的渲染 watcher），而新的写法将插槽内容放在了 scopedSlots 中，会在子组件的渲染函数中调用，插槽内容的依赖会被子组件收集（name 的 dep 收集到子组件的渲染 watcher），</strong>最终导致的结果就是：当我们修改 name 这个属性时，旧的写法是调用父组件的更新（调用父组件的渲染 watcher），然后在父组件更新过程中调用子组件更新（prePatch &#x3D;&gt; updateChildComponent），而新的写法则是直接调用子组件的更新（调用子组件的渲染 watcher）。这样一来，旧的写法在更新时就多了一个父组件更新的过程，而新的写法由于直接更新子组件，就会更加高效，性能更好，所以推荐始终使用<code>v-slot:slotName</code>语法。</p><h4 id="二、使用函数式组件"><a href="#二、使用函数式组件" class="headerlink" title="二、使用函数式组件"></a>二、使用函数式组件</h4><p>对于某些组件，如果我们只是用来显示一些数据，不需要管理状态，监听数据等，那么就可以用函数式组件。函数式组件是无状态的，无实例的，在初始化时不需要初始化状态，不需要创建实例，也不需要去处理生命周期等，相比有状态组件，会更加轻量，同时性能也更好。</p><pre><code class="vue">    &lt;template functional&gt;        &lt;div class=&quot;user-profile&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default &#123;            // or functional: true            props: [&#39;name&#39;],        &#125;    &lt;/script&gt;</code></pre><h4 id="三、结合场景使用-v-show-和-v-if"><a href="#三、结合场景使用-v-show-和-v-if" class="headerlink" title="三、结合场景使用 v-show 和 v-if"></a>三、结合场景使用 v-show 和 v-if</h4><pre><code>// v-if 编译前&lt;template&gt;  &lt;div&gt;    &lt;UserProfile :user=&quot;user1&quot; v-if=&quot;visible&quot; /&gt;    &lt;button @click=&quot;visible = !visible&quot;&gt;toggle&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;// 编译后function render() &#123;  with (this) &#123;    return _c(      &#39;div&#39;,      [        visible          ? _c(&#39;UserProfile&#39;, &#123;              attrs: &#123;                user: user1              &#125;            &#125;)          : _e(),        _c(          &#39;button&#39;,          &#123;            on: &#123;              click: function ($event) &#123;                visible = !visible              &#125;            &#125;          &#125;,          [_v(&#39;toggle&#39;)]        )      ],    )  &#125;&#125;</code></pre><pre><code>// v-show 编译前&lt;template&gt;  &lt;div&gt;    &lt;UserProfile :user=&quot;user1&quot; v-show=&quot;visible&quot; /&gt;    &lt;button @click=&quot;visible = !visible&quot;&gt;toggle&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;function render() &#123;  with (this) &#123;    return _c(      &#39;div&#39;,      [        _c(&#39;UserProfile&#39;, &#123;          directives: [            &#123;              name: &#39;show&#39;,              rawName: &#39;v-show&#39;,              value: visible,              expression: &#39;visible&#39;            &#125;          ],          attrs: &#123;            user: user1          &#125;        &#125;),        _c(          &#39;button&#39;,          &#123;            on: &#123;              click: function ($event) &#123;                visible = !visible              &#125;            &#125;          &#125;,          [_v(&#39;toggle&#39;)]        )      ],    )  &#125;&#125;</code></pre><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>v-show</code> 和 <code>v-if</code> 相比，不需要在 patch 阶段创建 &#x2F; 移除节点，只是根据v-show上绑定的值来控制 DOM 元素的<code>style.display</code>属性，在频繁切换的场景下就可以节省很多性能。</p><p>但是并不是说<code>v-show</code>可以在任何情况下都替换<code>v-if</code>，如果初始值是false时，<code>v-if</code>并不会创建隐藏的节点，但是<code>v-show</code>会创建，并通过设置<code>style.display=&#39;none&#39;</code>来隐藏，虽然外表看上去这个 DOM 都是被隐藏的，但是<code>v-show</code>已经完整的走了一遍创建的流程，造成了性能的浪费。所以，<code>v-if</code>的优势体现在初始化时，<code>v-show</code>体现在更新时，当然并不是要求你绝对按照这个方式来，比如某些组件初始化时会请求数据，而你想先隐藏组件，然后在显示时能立刻看到数据，这时候就可以用<code>v-show</code>，又或者你想每次显示这个组件时都是最新的数据，那么你就可以用<code>v-if</code>，所以我们要结合具体业务场景去选一个合适的方式。</p><h4 id="四、避免-v-for-和-v-if-同时使用"><a href="#四、避免-v-for-和-v-if-同时使用" class="headerlink" title="四、避免 v-for 和 v-if 同时使用"></a>四、避免 v-for 和 v-if 同时使用</h4><p>2.x 当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。<br>3.x 当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。</p><p>如果同时出现，每次渲染都会先执行循环在判断条件，无论如何循环都不可避免，浪费了性能,要避免出现这种情况，在外层嵌套<code>template</code>，在这一层进行v-if判断，然后在内部进行<code>v-for</code>循环。</p><h4 id="五、始终为-v-for-添加-key，并且不要将-index-作为的-key"><a href="#五、始终为-v-for-添加-key，并且不要将-index-作为的-key" class="headerlink" title="五、始终为 v-for 添加 key，并且不要将 index 作为的 key"></a>五、始终为 v-for 添加 key，并且不要将 index 作为的 key</h4><p>1.key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准的判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少了dom的操作量，提高性能。</p><p>2.如果不设置key可能在列表更新时引发一些隐藏的bug 比如说更新和不更新看不出来。</p><p>3.vue中在使用相同标签名元素的过渡切换是，也会用到key属性，其目的也是为了让vue可以区分他们，否则vue只会替换其内部属性而不会触发过渡效果。需要用key来作为唯一性的判断。</p><p>当用<code>index</code>作为<code>key</code>时，因为diff算法会就地更新，会复用key:0的这个节点，比对的时候，key:0的节点存在，则比对key:1，也存在，而多出了key:2, 则会将其删除。</p><h4 id="六、使用Object-freeze"><a href="#六、使用Object-freeze" class="headerlink" title="六、使用Object.freeze()"></a>六、使用Object.freeze()</h4><p>在 Vue 组件初始化数据时，会递归遍历在 data 中定义的每一条数据，通过Object.defineProperty将数据改成响应式，这就意味着如果 data 中的数据量很大的话，在初始化时将会使用很长的时间去执行Object.defineProperty, 也就会带来性能问题，这个时候我们可以强制使数据变为非响应式，从而节省时间。</p><p>对某一对象使用<code>Object.freeze()</code>后，将不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。在vue源码中判断条件中有一个<code>Object.isExtensible(value)</code>，这个方法是判断一个对象是否是可扩展的，由于我们使用了<code>Object.freeze()</code>，这里肯定就返回了false，所以就跳过了下面的数据响应绑定过程，自然就省了很多时间。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack之多入口&amp;三种hash</title>
      <link href="/2022/09/30/webpack-multiInput/"/>
      <url>/2022/09/30/webpack-multiInput/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack之多入口-amp-三种hash"><a href="#Webpack之多入口-amp-三种hash" class="headerlink" title="Webpack之多入口&amp;三种hash"></a>Webpack之多入口&amp;三种hash</h3><p>webpack三种hash</p><p>1.全局hash: <code>hash</code> 修改一个地方所有文件hash都改变</p><p>2.内容hash: <code>contentHash</code>  根据自身文件修改了才会变hash</p><p>3.分组hash: <code>chunkHash</code>  根据多入口文件分组 不同组之间hash值不相影响， 组内文件修改，该组hash改变</p><h4 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h4><pre><code class="js">    module.exports = &#123;        entry: &#123;            main: &#39;./js/main.js&#39;,            other: &#39;./js/other.js&#39;        &#125;,        output: &#123;            filename: &#39;[name].[hash/contentHash/chunkHash].js&#39;,            path: path.resolve(__dirname, &#39;dist&#39;)        &#125;,        plugins: [            new HtmlWebpackPlugin(&#123;                filename: &#39;index.html&#39;,                template: &#39;./src/index.html&#39;,                chunks: [&#39;main&#39;]            &#125;),            new HtmlWebpackPlugin(&#123;                filename: &#39;other.html&#39;,                template: &#39;./src/other.html&#39;,                chunks: [&#39;other&#39;]            &#125;),        ]        // ...    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack之抽离压缩css</title>
      <link href="/2022/09/30/webpack-optimization/"/>
      <url>/2022/09/30/webpack-optimization/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack之抽离压缩css"><a href="#Webpack之抽离压缩css" class="headerlink" title="Webpack之抽离压缩css"></a>Webpack之抽离压缩css</h3><p>使用 <code>mini-css-extract-plugin</code> 插件的内置loader 替换 <code>style-loader</code></p><p>使用 <code>terser-webpack-plugin</code> 插件压缩js代码</p><p>使用 <code>optimize-css-assets-webpack-plugin</code> 插件压缩css代码</p><h4 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h4><pre><code class="js">    const MiniCSSExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);        const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);  // 压缩js插件    const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);  // 压缩css插件        module.exports = &#123;        // ...        module: &#123;            rules: [                &#123;                    test: /\.css/,                    loader: [                        MiniCSSExtractPlugin.loader, // 替换 style-loader                        &#39;css-loader&#39;,                        &#39;postcss-loader&#39;,  // autoprefixer                    ],                &#125;            ]        &#125;,        plugins: [            new MiniCSSExtractPlugin(&#123;                filename: &#39;css/main.[contentHash:8].css&#39;            &#125;)        ],        // 优化配置        optimization: &#123;            minimizer: &#123;                // 压缩js                new TerserPlugin(),                // 压缩css                new OptimizeCssAssetsWebpackPlugin()            &#125;        &#125;      &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack之拆分/合并配置</title>
      <link href="/2022/09/30/webpack-mergeConfig/"/>
      <url>/2022/09/30/webpack-mergeConfig/</url>
      
        <content type="html"><![CDATA[<h3 id="Webpack之拆分-x2F-合并配置"><a href="#Webpack之拆分-x2F-合并配置" class="headerlink" title="Webpack之拆分&#x2F;合并配置"></a>Webpack之拆分&#x2F;合并配置</h3><p>使用 <code>webpack-merge</code> 合并配置；</p><p>对应script为：<br>build:dev webpack –config webpack.dev.config.js；<br>build:prod webpack –config webpack.prod.config.js；</p><h4 id="webpack-base-config-js"><a href="#webpack-base-config-js" class="headerlink" title="webpack.base.config.js"></a>webpack.base.config.js</h4><p>提取公共配置</p><pre><code class="js">    const path = requrie(&#39;path&#39;);    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);        module.exports = &#123;        entry: &#123;            main: &#39;./src/index.js&#39;        &#125;,        output: &#123;            filename: &#39;[name].js&#39;,            path: path.resolve(__dirname, &#39;dist&#39;)        &#125;,        plugins: [            new HtmlWebpackPlugin(&#123;                template: &#39;./src/index.html&#39;            &#125;)        ],        // ...    &#125;</code></pre><h4 id="webpack-dev-config-js"><a href="#webpack-dev-config-js" class="headerlink" title="webpack.dev.config.js"></a>webpack.dev.config.js</h4><p>开发环境配置</p><pre><code class="js">    const baseConfig = require(&#39;./weback.base.config.js&#39;);    const &#123; smart: merge &#125; = require(&#39;webpack-merge&#39;);        const devConfig = &#123;        mode: &#39;development&#39;        // 开发环境配置....    &#125;        module.export = merge(baseConfig, devConfig);</code></pre><h4 id="webpack-prod-config-js"><a href="#webpack-prod-config-js" class="headerlink" title="webpack.prod.config.js"></a>webpack.prod.config.js</h4><p>生产环境配置</p><pre><code class="js">    const baseConfig = require(&#39;./weback.base.config.js&#39;);    const &#123; smart: merge &#125; = require(&#39;webpack-merge&#39;);        const devConfig = &#123;        mode: &#39;development&#39;        // 开发环境配置....    &#125;        module.export = merge(baseConfig, devConfig);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里oss上传工具函数</title>
      <link href="/2022/09/30/js-aliOssUpload/"/>
      <url>/2022/09/30/js-aliOssUpload/</url>
      
        <content type="html"><![CDATA[<h3 id="阿里oss上传工具函数"><a href="#阿里oss上传工具函数" class="headerlink" title="阿里oss上传工具函数"></a>阿里oss上传工具函数</h3><p><strong>ps:</strong> <em>现在很多图片上传都是托管到阿里云oss上的,前端方法如下</em></p><h4 id="安装-ali-oss"><a href="#安装-ali-oss" class="headerlink" title="安装 ali-oss"></a>安装 ali-oss</h4><p><code>compressorjs</code>用来压缩图片，<code>ali-oss</code>用来上传oss</p><pre><code class="bash">    npm install ali-oss    npm install compressorjs</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    import OSS from &#39;ali-oss&#39;;    import Compressor from &#39;compressorjs&#39;;    import &#123; randomString &#125; from &#39;@/utils/index.js&#39;;    const &#123; accessKeyId, accessKeySecret, region, endpoint &#125; = &#123;    region: &#39;your region&#39;,    accessKeyId: &#39;your accessKeyId&#39;,    accessKeySecret: &#39;your accessKeySecret&#39;,    endpoint: &#39;oss-cn-hangzhou.aliyuncs.com&#39;    &#125;;    const client = new OSS(&#123;    // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。    region: region,    // 从STS服务获取的临时访问密钥（AccessKey ID和AccessKey Secret）。    accessKeyId: accessKeyId,    accessKeySecret: accessKeySecret,    endpoint: endpoint,    // 填写Bucket名称。    bucket: &#39;mdhw&#39;    &#125;);    /**     * 图片压缩     */    function compressImage(fileList, backType, limitSize, quality) &#123;    const promiseAry = [];    const maxSize = limitSize * 1024 * 1024;    fileList.forEach(image =&gt; &#123;        promiseAry.push(new Promise((resolve, reject) =&gt; &#123;        if (image.size &lt;= maxSize) &#123; // 没操过限制，不用压缩            resolve(image)        &#125;        else &#123;            new Compressor(image, &#123;            // maxWidth: 750,            // maxHeight: 750,            quality: quality || 0.8,            success(result) &#123;                let file = new File([result], image.name, &#123; type: image.type &#125;)                if (!backType || backType == &#39;blob&#39;) &#123;                resolve(result)                &#125; else if (backType == &#39;file&#39;) &#123;                resolve(file)                &#125; else &#123;                resolve(file)                &#125;            &#125;,            error(err) &#123;                console.log(&#39;图片压缩失败----&gt;&gt;&gt;&gt;&gt;&#39;, err)                resolve(image)            &#125;            &#125;)        &#125;        &#125;))    &#125;)    return Promise.all(promiseAry)    &#125;    const defaultLimit = 1;    /**     *     * @param fileList 上传图片的资源路径     * @param dir oss要保存的文件夹     * @param limitSize oss图片限制 默认1m 0为不限制     * @returns &#123;OSS文件路径&#125;     */    async function uploadOSS(fileList, dir = &#39;file&#39;, &#123;    limitSize = defaultLimit, compress = false    &#125;) &#123;    return new Promise((resolve, reject) =&gt; &#123;        const promiseAry = [];        let randomVal, randomStr, imgtype, fileName, tmpAry, maxSize = limitSize * 1024 * 1024;        let _Promise = compress ? compressImage(fileList, &#39;file&#39;, limitSize) : Promise.resolve(fileList)        if (compress) &#123;        console.log(&#39;压缩前的图片列表&#39;, fileList)        &#125;        _Promise.then(fileList =&gt; &#123;        if (compress) &#123;            console.log(&#39;压缩后的图片列表&#39;, fileList)        &#125;        const canUploadList = limitSize == 0 ? fileList : fileList.filter(file =&gt; file.size &lt;= maxSize);        canUploadList.forEach(file =&gt; &#123;            tmpAry = file.name.split(&#39;.&#39;);            imgtype = tmpAry[tmpAry.length - 1]            randomVal = +new Date();            randomStr = randomString()            fileName = `$&#123;randomVal&#125;_$&#123;randomStr&#125;.$&#123;imgtype&#125;`            promiseAry.push(client.put(`$&#123;dir&#125;/$&#123;fileName&#125;`, file, &#123;            headers: &#123;                &#39;aa&#39;: &#39;aa&#39;            &#125;            &#125;))        &#125;)        Promise.all(promiseAry).then(result =&gt; &#123;            let code = canUploadList.length == fileList.length ? 1 : 0            resolve(&#123;            result,            code,            msg: code == 1 ? &#39;上传成功&#39; : `$&#123;fileList.length == 1 ? &#39;&#39; : &#39;部分&#39;&#125;图片大小超过$&#123;limitSize&#125;M`            &#125;);        &#125;).catch(e =&gt; &#123;            reject(e)        &#125;)        &#125;)    &#125;);    &#125;    export &#123; uploadOSS, defaultLimit &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI二开Alioss上传组件</title>
      <link href="/2022/09/30/vue-ossUploadComponent/"/>
      <url>/2022/09/30/vue-ossUploadComponent/</url>
      
        <content type="html"><![CDATA[<h3 id="ElementUI二开Alioss上传组件"><a href="#ElementUI二开Alioss上传组件" class="headerlink" title="ElementUI二开Alioss上传组件"></a>ElementUI二开Alioss上传组件</h3><p>本文代码只是vue前端组件代码，还需要依赖<code>vuedraggable</code>组件库（支持拖拽排序）；还需要<strong>ossUpload.js</strong>工具函数（详见另外一文：<em><strong>阿里oss上传工具函数</strong></em>）</p><p>该组件写的时候大部分都是参照elementUI的上传组件（其实是本来的业务代码都是通过后端上传，后面领导说要用oss，所以就写了这个组件），所以使用到了elementUI的部分组件</p><h4 id="vue-Code"><a href="#vue-Code" class="headerlink" title="vue Code"></a>vue Code</h4><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;flex-wrap&quot;&gt;      &lt;div class=&quot;oss-upload&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;label v-if=&quot;!disabled&quot; class=&quot;hand&quot;&gt;          &lt;input            :multiple=&quot;multiple&quot;            type=&quot;file&quot;            class=&quot;hidden&quot;            @change=&quot;change&quot;          /&gt;        &lt;/label&gt;      &lt;/div&gt;      &lt;el-button        v-if=&quot;!disabled &amp;&amp; onDelete &amp;&amp; value&quot;        @click=&quot;handleDelete&quot;        type=&quot;text&quot;        size=&quot;small&quot;        &gt;删除&lt;/el-button      &gt;      &lt;slot name=&quot;tips&quot;&gt;        &lt;span class=&quot;tips&quot;&gt;&#123;&#123; tips &#125;&#125;&lt;/span&gt;      &lt;/slot&gt;    &lt;/div&gt;    &lt;draggable      class=&quot;drag-list&quot;      v-if=&quot;!disabled &amp;&amp; showFileList &amp;&amp; filelist.length &gt; 0&quot;      v-model=&quot;filelist&quot;      @change=&quot;drag&quot;    &gt;      &lt;div class=&quot;drag-item&quot; v-for=&quot;(item, idx) in filelist&quot; :key=&quot;idx&quot;&gt;        &lt;img class=&quot;drag-item-img&quot; :src=&quot;item&quot; /&gt;        &lt;i class=&quot;el-icon-error&quot; @click=&quot;remove(idx)&quot;&gt;&lt;/i&gt;      &lt;/div&gt;    &lt;/draggable&gt;    &lt;template v-else-if=&quot;showFileList &amp;&amp; filelist.length &gt; 0&quot;&gt;      &lt;div class=&quot;drag-list&quot;&gt;        &lt;div class=&quot;drag-item&quot; v-for=&quot;(item, idx) in filelist&quot; :key=&quot;idx&quot;&gt;          &lt;img class=&quot;drag-item-img&quot; :src=&quot;item&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import draggable from &quot;vuedraggable&quot;;import &#123; uploadOSS, defaultLimit &#125; from &quot;@/utils/ossUpload&quot;;export default &#123;  components: &#123;    draggable,  &#125;,  props: &#123;    value: String,    limit: [String, Number],    maxCount: [String, Number],    tips: String,    disabled: &#123;      type: Boolean,      default: false,    &#125;,    compress: &#123;      type: Boolean,      default: false,    &#125;,    showUploadResult: &#123;      type: Boolean,      default: true,    &#125;,    multiple: &#123;      type: Boolean,      default: false,    &#125;,    showFileList: &#123;      type: Boolean,      default: false,    &#125;,    fileList: &#123;      type: Array,      default: () =&gt; [],    &#125;,    onBeforeUpload: &#123;      type: Function,      default: () =&gt; &#123;&#125;,    &#125;,    onSuccess: &#123;      type: Function,      default: () =&gt; &#123;&#125;,    &#125;,    onError: &#123;      type: Function,      default: () =&gt; &#123;&#125;,    &#125;,    onChange: &#123;      type: Function,      default: () =&gt; &#123;&#125;,    &#125;,    onDelete: &#123;      type: Function,      default: null,    &#125;,    dir: &#123;      type: String,      default: &quot;file&quot;,    &#125;,  &#125;,  watch: &#123;    fileList: &#123;      handler(val) &#123;        this.filelist = val || [];      &#125;,      immediate: true,    &#125;,  &#125;,  data() &#123;    return &#123;      filelist: [],    &#125;;  &#125;,  methods: &#123;    clearFileList() &#123;      this.filelist = [];    &#125;,    handleDelete() &#123;      this.onDelete &amp;&amp; this.onDelete();    &#125;,    remove(index) &#123;      this.filelist = this.filelist.filter((item, idx) =&gt; idx !== index);      this.onChange(this.filelist);    &#125;,    drag() &#123;      this.onChange(this.filelist);    &#125;,    change(e) &#123;      const files = Array.from(e.target.files);      const limit = Number(this.limit);      const maxCount = Number(this.maxCount);      if (maxCount === maxCount) &#123;        // maxCount值有效，则限制数量        if (this.filelist.length + files.length &gt; maxCount) &#123;          this.$message.warning(`最多上传$&#123;maxCount&#125;张图片`);          return;        &#125;      &#125;      // 限制图片类型      const _files = files.filter((d) =&gt; &#123;        if (d.type == &quot;image/png&quot; || d.type == &quot;image/jpeg&quot;) &#123;          return true;        &#125; else &#123;          return false;        &#125;      &#125;);      e.target.value = null;      // 存在不符合的图片类型      if (_files.length !== files.length) &#123;        this.$message.warning(&quot;图片类型不是png或者jpeg&quot;);      &#125;      // 没有有效的图片直接返回      if (_files.length === 0) &#123;        return;      &#125;      this.onBeforeUpload(); // 上传前钩子      uploadOSS(_files, this.dir, &#123;        limitSize: isNaN(limit) ? defaultLimit : limit,        compress: this.compress,      &#125;)        .then((&#123; result, code, msg &#125;) =&gt; &#123;          this.showUploadResult &amp;&amp;            this.$message(&#123;              type: code == 1 ? &quot;success&quot; : &quot;warning&quot;,              message: msg,            &#125;);          result.forEach((res) =&gt; &#123;            this.filelist.push(res.url);          &#125;);          if (this.multiple || this.filelist[this.filelist.length - 1]) &#123;            this.onSuccess(              result,              this.multiple                ? this.filelist                : this.filelist[this.filelist.length - 1]            );          &#125;        &#125;)        .catch((err) =&gt; &#123;          console.error(err);          this.onError(err);        &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.oss-upload img &#123;  display: block;&#125;.flex-wrap &#123;  display: inline-flex;  align-items: center;&#125;.oss-upload &#123;  display: inline-block;  position: relative;  margin-right: 10px;&#125;.hand &#123;  z-index: 99;  cursor: pointer;  position: absolute;  top: 0;  left: 0;  right: 0;  bottom: 0;&#125;.hidden &#123;  display: none;&#125;.el-icon-error &#123;  position: absolute;  right: -7px;  top: -7px;  font-size: 18px;  cursor: pointer;  color: #f56c6c;&#125;.drag-list &#123;  display: flex;  flex-wrap: wrap;  padding: 20px 0;&#125;.drag-item &#123;  position: relative;  margin-right: 10px;&#125;.drag-item-img &#123;  object-fit: contain;  width: 100px;  height: 100px;  border: 1px solid #ddd;  border-radius: 4px;&#125;.tips &#123;  font-size: 12px;  color: #999;&#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI二开商品规格组件</title>
      <link href="/2022/09/30/vue-goodsSkuComponent/"/>
      <url>/2022/09/30/vue-goodsSkuComponent/</url>
      
        <content type="html"><![CDATA[<h3 id="ElementUI二开商品规格组件"><a href="#ElementUI二开商品规格组件" class="headerlink" title="ElementUI二开商品规格组件"></a>ElementUI二开商品规格组件</h3><p>使用到<code>element-ui</code>进行二次开发的组件</p><p>电商后台需求-商品规格组件，参数是我们业务上需要的，不过八九不离十</p><p>组件中的上传图片使用了oss-upload组件（详见另一文：<em><strong>ElementUI二开Alioss上传组件</strong></em>）</p><p><a href="https://postimg.cc/WFhBcd5r"><img src="https://i.postimg.cc/C1NSDDDv/goodsSku.png" alt="goodsSku.png"></a></p><h4 id="vue-Code"><a href="#vue-Code" class="headerlink" title="vue Code"></a>vue Code</h4><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;sku-list&quot;&gt;    &lt;template v-if=&quot;!disabled&quot;&gt;      &lt;div class=&quot;sku-list-head&quot;&gt;        &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;addSkuRow&quot;          &gt;添加规格&lt;/el-button        &gt;      &lt;/div&gt;      &lt;div        class=&quot;sku-list-item&quot;        v-for=&quot;(item, index) in skuData.attrList&quot;        :key=&quot;index&quot;      &gt;        &lt;div class=&quot;sku-list-item-main&quot;&gt;          &lt;div class=&quot;sku-list-item__layout&quot;&gt;            &lt;span class=&quot;span&quot;&gt;规格名&lt;/span&gt;            &lt;el-input              size=&quot;small&quot;              v-model=&quot;item.attrName&quot;              class=&quot;input&quot;            &gt;&lt;/el-input&gt;          &lt;/div&gt;          &lt;div class=&quot;sku-list-item__layout&quot;&gt;            &lt;span class=&quot;span&quot;&gt;规格值&lt;/span&gt;            &lt;div class=&quot;sku-list-item-tags&quot;&gt;              &lt;el-tag                class=&quot;sku-list-item-tag&quot;                closable                @close=&quot;removeSkuAttr(index)&quot;                v-for=&quot;(subitem, i) in item.attrValue&quot;                :key=&quot;i&quot;                &gt;&#123;&#123; subitem.attrValue &#125;&#125;&lt;/el-tag              &gt;              &lt;el-button                size=&quot;small&quot;                icon=&quot;el-icon-plus&quot;                @click=&quot;addSkuAttr(index)&quot;                &gt;添加&lt;/el-button              &gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;el-button          type=&quot;text&quot;          size=&quot;small&quot;          class=&quot;sku-list-item-removeBtn&quot;          @click=&quot;removeSkuRow(index)&quot;          &gt;删除规格&lt;/el-button        &gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;el-table border :data=&quot;skuData.skuList&quot;&gt;      &lt;el-table-column label=&quot;图片&quot; align=&quot;center&quot; width=&quot;120&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;oss-upload            :disabled=&quot;disabled&quot;            :on-success=&quot;              (res, file) =&gt; onUploadImgSuccess(res, file, scope.row)            &quot;            dir=&quot;erp/goods&quot;          &gt;            &lt;img              v-if=&quot;scope.row.icon&quot;              :src=&quot;scope.row.icon&quot;              class=&quot;goods-img&quot;            /&gt;            &lt;el-button v-else-if=&quot;!disabled&quot; type=&quot;text&quot; size=&quot;small&quot;              &gt;上传图片&lt;/el-button            &gt;          &lt;/oss-upload&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column        label=&quot;规格&quot;        align=&quot;center&quot;        prop=&quot;attrPath&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;供货价格&quot; align=&quot;center&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-input            :readonly=&quot;disabled&quot;            v-model=&quot;scope.row.priceCost&quot;          &gt;&lt;/el-input&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;销售价格&quot; align=&quot;center&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-input            :readonly=&quot;disabled&quot;            v-model=&quot;scope.row.priceCash&quot;          &gt;&lt;/el-input&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;划线价格&quot; align=&quot;center&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-input            :readonly=&quot;disabled&quot;            v-model=&quot;scope.row.priceOriginal&quot;          &gt;&lt;/el-input&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;商品库存&quot; align=&quot;center&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-input :readonly=&quot;disabled&quot; v-model=&quot;scope.row.stock&quot;&gt;&lt;/el-input&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;!-- &lt;el-table-column label=&quot;商品预警值&quot; align=&quot;center&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-input :readonly=&quot;disabled&quot; v-model=&quot;scope.row.stock&quot;&gt;&lt;/el-input&gt;        &lt;/template&gt;      &lt;/el-table-column&gt; --&gt;      &lt;!-- &lt;el-table-column v-if=&quot;!disabled&quot; label=&quot;操作&quot; align=&quot;center&quot;&gt;        &lt;template&gt;          &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt;          &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;上移&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt; --&gt;    &lt;/el-table&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  model: &#123;    prop: &quot;skuData&quot;,    event: &quot;change&quot;,  &#125;,  props: &#123;    skuData: &#123;      type: Object,      default: () =&gt; (&#123;&#125;),    &#125;,    disabled: &#123;      type: Boolean,      default: false,    &#125;,  &#125;,  data() &#123;    return &#123;&#125;;  &#125;,  watch: &#123;    &quot;skuData.attrList&quot;: &#123;      handler() &#123;        if (!this.disabled) &#123;          this.$set(this.skuData, &quot;skuList&quot;, this.getTable());        &#125;      &#125;,      deep: true,      immediate: true,    &#125;,  &#125;,  methods: &#123;    // 添加规格行    addSkuRow(i) &#123;      this.skuData.attrList.push(&#123;        attrName: &quot;&quot;,        attrValue: [],      &#125;);      this.$emit(&quot;change&quot;, this.skuData);    &#125;,    // 删除规格行    removeSkuRow(i) &#123;      this.skuData.attrList.splice(i, 1);      this.$emit(&quot;change&quot;, this.skuData);    &#125;,    // 删除规格属性值    removeSkuAttr(a, b) &#123;      this.skuData.attrList[a].attrValue.splice(b, 1);      this.$emit(&quot;change&quot;, this.skuData);    &#125;,    // 添加规格属性值    addSkuAttr(i) &#123;      this.$prompt(&quot;请输入规格值&quot;, &quot;添加规格值&quot;, &#123;        confirmButtonText: &quot;确定&quot;,        cancelButtonText: &quot;取消&quot;,        inputPattern: /\S+/,        inputErrorMessage: &quot;规格值不能为空&quot;,        closeOnClickModal: false,      &#125;).then((&#123; value &#125;) =&gt; &#123;        this.skuData.attrList[i].attrValue.push(&#123;          attrValue: value,        &#125;);        this.$emit(&quot;change&quot;, this.skuData);      &#125;);    &#125;,    onUploadImgSuccess(res, file, row) &#123;      if (!file) &#123;        return;      &#125;      row.icon = file;      this.$emit(&quot;change&quot;, this.skuData);    &#125;,    getTable() &#123;      const table = [];      const attrValueAry = [];      const arr = [];      const tmpSkuData = (this.skuData.attrList || []).filter(        (d) =&gt; d.attrName != &quot;&quot; &amp;&amp; d.attrValue.length &gt; 0      );      if (!tmpSkuData || tmpSkuData.length == 0) &#123;        return [];      &#125;      tmpSkuData.forEach((item) =&gt; &#123;        attrValueAry.push(item.attrValue);      &#125;);      function func(skuarr = [], i) &#123;        for (let j = 0; j &lt; attrValueAry[i].length; j++) &#123;          if (i &lt; attrValueAry.length - 1) &#123;            skuarr[i] = attrValueAry[i][j];            func(skuarr, i + 1);          &#125; else &#123;            arr.push([...skuarr, attrValueAry[i][j]]);          &#125;        &#125;      &#125;      func([], 0);      arr.forEach((item) =&gt; &#123;        let attrPath = &quot;&quot;,          findItem,          tableItem;        item.forEach((d, idx) =&gt; &#123;          attrPath += `$&#123;tmpSkuData[idx].attrName&#125;:$&#123;d.attrValue&#125;;`;        &#125;);        findItem =          this.skuData.initSkulist.find((item) =&gt; &#123;            return attrPath.includes(item.attrPath);          &#125;) || &#123;&#125;;        tableItem = Object.assign(          &#123;            priceCost: 0,            priceCash: 0,            priceOriginal: 0,            stock: 0,            icon: null,          &#125;,          findItem,          &#123;            attrPath,          &#125;        );        table.push(tableItem);      &#125;);      return table;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.sku-list &#123;  &amp;-head &#123;    margin-bottom: 10px;  &#125;  &amp;-item &#123;    display: flex;    align-items: center;    border: 1px solid #eee;    border-radius: 5px;    margin-bottom: 20px;    padding: 20px 50px;    &amp;-main &#123;      flex: 1;    &#125;    &amp;-removeBtn &#123;      margin-left: 20px;      color: #f56c6c;    &#125;    &amp;__layout &#123;      display: flex;      align-items: center;      margin-bottom: 20px;      &amp;:last-child &#123;        margin-bottom: 0;      &#125;      .input &#123;        width: 240px;      &#125;      .span &#123;        font-size: 13px;        font-weight: bold;        margin-right: 10px;      &#125;    &#125;    &amp;-tags &#123;      flex: 1;    &#125;    &amp;-tag &#123;      margin-bottom: 10px;      margin-right: 10px;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue项目动态制定图片</title>
      <link href="/2022/09/30/vue-mergeImg/"/>
      <url>/2022/09/30/vue-mergeImg/</url>
      
        <content type="html"><![CDATA[<h3 id="vue项目动态制定图片"><a href="#vue项目动态制定图片" class="headerlink" title="vue项目动态制定图片"></a>vue项目动态制定图片</h3><p><strong>ps:</strong> <em>业务需求：需要在一张指定的背景图上放一张代表用户信息的二维码，并在二维码底部写一些编号，然后生成一张图片下载…</em></p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p><code>js-file-download</code> 可以用来下载图片；</p><p><code>merge-images</code> 可以把两张图片合成一张；</p><p><code>qrcode</code> 可以动态生成二维码图片；</p><pre><code class="bash">    npm i js-file-download    npm i merge-images    npm i qrcode </code></pre><h4 id="vue-Code"><a href="#vue-Code" class="headerlink" title="vue Code"></a>vue Code</h4><pre><code class="vue">&lt;script&gt;    import fileDownload from &quot;js-file-download&quot;;    import mergeImages from &quot;merge-images&quot;;    import QRCode from &quot;qrcode&quot;;    export default &#123;        methods:&#123;            downloadItem(ary, sleep = 1000)&#123;                let row = ary.shift();                if(!row)&#123;                    return                &#125;                let textImg = drawText(&#123;                    text: `$&#123;row.loginName&#125;_$&#123;row.shareCount&#125;`,                    color: &quot;#fff&quot;,                    fontSize: 30,                    width: &quot;750&quot;,                &#125;);                this.makeQrCode(row.shareCode).then((url) =&gt; &#123;                    mergeImages(                        [                        &quot;https://mdhw.oss-cn-hangzhou.aliyuncs.com/h5/share_bg.png?v=2.0&quot;,                        &#123; src: url, x: 149, y: 478 &#125;,                        &#123; src: textImg, x: 0, y: 995 &#125;,                        ],                        &#123;                        crossOrigin: &quot;Anonymous&quot;,                        &#125;                    ).then((b64) =&gt; &#123;                        fileDownload(                            dataURLtoFile(b64),                            `$&#123;row.loginName&#125;_$&#123;row.shareCount&#125;.png`                        );                        // 需要延时下载，因为如果批量下载的 且不延时 那么会导致批量下载的图片部分丢失                        setTimeout(()=&gt;&#123;                            this.downloadItem(ary, sleep)                        &#125;, sleep)                    &#125;);                &#125;);            &#125;,                    makeQrCode(shareCode) &#123;                return QRCode.toDataURL(                    `https://www.nairongmiao.xyz/share.html?shareCode=$&#123;shareCode&#125;`,                    &#123;                    errorCorrectionLevel: &quot;H&quot;,                    width: 477,                    margin: 1,                    &#125;                );            &#125;,        &#125;    &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue项目页面增加水印</title>
      <link href="/2022/09/30/vue-waterMark/"/>
      <url>/2022/09/30/vue-waterMark/</url>
      
        <content type="html"><![CDATA[<h3 id="vue项目页面增加水印"><a href="#vue项目页面增加水印" class="headerlink" title="vue项目页面增加水印"></a>vue项目页面增加水印</h3><p><strong>ps:</strong> <em>领导说要在后台上面添加带上用户名字的水印，嗯…加个指令…，还有就是可能需要使用<code>pointer-event: none;</code>来让这个水印层不会影响到页面的事件操作</em></p><h4 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h4><pre><code class="js">    Vue.directive(&#39;watermark&#39;, (el,binding) =&gt; &#123;        let text = binding.value.text;        let font = binding.value.font || &quot;16px Microsoft JhengHei&quot;;        let textColor = binding.value.textColor || &quot;rgba(215, 215, 215, 0.2)&quot;;        let width = binding.value.width || 400;        let height = binding.value.height || 200;        let textRotate = binding.value.textRotate||-20;                function addWaterMarker(parentNode) &#123;            var can = document.createElement(&#39;canvas&#39;);            var cans = can.getContext(&#39;2d&#39;);            parentNode.appendChild(can);            can.width = width;            can.height = height;            can.style.display = &#39;none&#39;;            cans.rotate(textRotate * Math.PI / 180);            cans.font = font;            cans.fillStyle = textColor ;            cans.textAlign = &#39;left&#39;;            cans.textBaseline = &#39;Middle&#39;;            cans.fillText(text, 0,  can.height);            parentNode.style.backgroundImage = &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;)&quot;;        &#125;        addWaterMarker(el)    &#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue项目小优化配置</title>
      <link href="/2022/09/30/vue-optimization/"/>
      <url>/2022/09/30/vue-optimization/</url>
      
        <content type="html"><![CDATA[<h3 id="vue项目小优化配置"><a href="#vue项目小优化配置" class="headerlink" title="vue项目小优化配置"></a>vue项目小优化配置</h3><p><strong>ps:</strong> <em>部署到线上的时候网页加载很慢…，领导叫我去优化下，于是就直接用<code>gzip</code>压缩大法，但是需要后端配合开启gzip，嗯…速度飞起…</em></p><p><code>webpack-bundle-analyzer</code>可以帮我们进行打包分析，避免重复打包，以及合理代码分割</p><h4 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h4><pre><code class="js">    const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;    chainWebpack(config)&#123;        // ...        config            .when(process.env.NODE_ENV !== &#39;development&#39;,                config =&gt; &#123;                    /* 打包分析插件 */                    config                        .plugin(&#39;webpackBundleAnalyzer&#39;)                        .use(BundleAnalyzerPlugin)                    /* 开启gzip压缩，需要后端配合 */                    config                        .plugin(&#39;compressionWebpackPlugin&#39;)                        .use(&#39;compression-webpack-plugin&#39;, [&#123;                            filename: &#39;[path].gz[query]&#39;,                            algorithm: &#39;gzip&#39;,                            test: new RegExp(&quot;\\.(&quot; + productionGzipExtensions.join(&quot;|&quot;) + &quot;)$&quot;),                            threshold: 10240,                            minRatio: 0.8,                            deleteOriginalAssets: false                        &#125;])                    /* 配置打包后删除console.log和debugger */                    config.optimization.minimizer(&#39;terser&#39;).tap((args) =&gt; &#123;                        args[0].terserOptions.compress.drop_debugger = true                        args[0].terserOptions.compress.pure_funcs = [&#39;console.log&#39;]                        return args                    &#125;)                    /* 代码分割 */                    config                        .optimization.splitChunks(&#123;                            chunks: &#39;all&#39;, // all-同步异步都分割,inital-对同步分割,async-对异步分割                            cacheGroups: &#123;                                libs: &#123;                                    name: &#39;chunk-libs&#39;, // 组名                                    test: /[\\/]node_modules[\\/]/,                                    priority: 10, // 优先级                                    /* minSize: 5 * 1024 // 达到5kb才分割 */                                    /* minChunks: 1 // 引用1次就单独打包 */                                &#125;,                                elementUI: &#123;                                    name: &#39;chunk-elementUI&#39;,                                     priority: 20,                                     test: /[\\/]node_modules[\\/]_?element-ui(.*)/                                 &#125;,                                commons: &#123;                                    name: &#39;chunk-commons&#39;,                                    test: resolve(&#39;src/components&#39;),                                     minChunks: 3,                                    priority: 5,                                    reuseExistingChunk: true                                &#125;                            &#125;                        &#125;)                &#125;            )    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP处理图片</title>
      <link href="/2022/09/29/php-dealImage/"/>
      <url>/2022/09/29/php-dealImage/</url>
      
        <content type="html"><![CDATA[<h3 id="使用GD库实现图片处理工具函数"><a href="#使用GD库实现图片处理工具函数" class="headerlink" title="使用GD库实现图片处理工具函数"></a>使用GD库实现图片处理工具函数</h3><p><strong>ps:</strong> <em>使用php完成对图片的裁切或者调整图片大小(缩放)</em></p><h4 id="php-Code"><a href="#php-Code" class="headerlink" title="php Code"></a>php Code</h4><pre><code class="php">&lt;?php    /* img_deal(String $file,String $save,Array $options)参数        $file 用户上传文件的路径        $save 保存的路径            $options参数:        - type 裁切(clip)或者是缩放(scale) 默认裁切            - scale参数 (至少写一个参数)        - scale_w 缩放后的宽度 (如果只设置其中一值则按原图比例缩放)        - scale_h 缩放后的高度            - clip参数 (全都得写)        - clip_w 裁切后的宽度        - clip_h 裁切后的高度        - clip_x 裁切起点x坐标(以图片左上顶点为原点,向下y正方向,向右x正方向)        - clip_y 裁切起点y坐标    */    function img_deal($file,$save,$options)&#123;            //上传的原图片        $img_src = imagecreatefromjpeg($file);        //原图片的宽高        $src_w = imagesx($img_src);        $src_h = imagesy($img_src);                switch ($options[&#39;type&#39;]) &#123;            case &#39;scale&#39;:                if(is_numeric($options[&#39;scale_w&#39;]) &amp;&amp; is_numeric($options[&#39;scale_h&#39;]))&#123;                    $dist_w = $options[&#39;scale_w&#39;];                    $dist_h = $options[&#39;scale_h&#39;];                &#125;elseif(is_numeric($options[&#39;scale_w&#39;]))&#123;                    $dist_w = $options[&#39;scale_w&#39;];                    $dist_h = $src_h*$dist_w/$src_w;                &#125;elseif(is_numeric($options[&#39;scale_h&#39;]))&#123;                    $dist_h = $options[&#39;scale_h&#39;];                    $dist_w = $src_w*$dist_h/$src_h;                &#125;else&#123;                    echo &#39;Image deal is Failed&lt;br&gt;&#39;;                    return false;                &#125;                //设置目标图片大小                $img_dist = imagecreatetruecolor($dist_w,$dist_h);                //图片进行处理                imagecopyresampled($img_dist, $img_src, 0, 0, 0, 0, $dist_w, $dist_h, $src_w, $src_h);                    break;                        default:                //设置目标图片大小                $img_dist = imagecreatetruecolor($options[&#39;clip_w&#39;],$options[&#39;clip_h&#39;]);                $keys = array_keys($options);                $str = implode($keys, &#39;,&#39;);                preg_match_all(&#39;/clip_/&#39;, $str, $matches);                if(count($matches[0]) !== 4)&#123;                    echo &#39;Image deal is Failed&lt;br&gt;&#39;;                    return false;                &#125;                    //图片进行处理                imagecopyresampled($img_dist, $img_src, 0, 0, $options[&#39;clip_x&#39;], $options[&#39;clip_y&#39;], $options[&#39;clip_w&#39;], $options[&#39;clip_h&#39;], $options[&#39;clip_w&#39;], $options[&#39;clip_h&#39;]);                                break;                        &#125;        //将图片保存        $status = imagejpeg($img_dist,$save);        if($status)&#123;            echo &#39;Image deal is Success&lt;br&gt;&#39;;        &#125;else&#123;            echo &#39;Image deal is Failed&lt;br&gt;&#39;;        &#125;        //释放内存空间        imagedestroy($img_dist);        imagedestroy($img_src);            //返回保存状态结果        return $status;        &#125; ?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios拦截器配置</title>
      <link href="/2022/09/29/axios-axiosInterceptor/"/>
      <url>/2022/09/29/axios-axiosInterceptor/</url>
      
        <content type="html"><![CDATA[<h3 id="axios拦截器配置"><a href="#axios拦截器配置" class="headerlink" title="axios拦截器配置"></a>axios拦截器配置</h3><p><strong>ps:</strong> <em>http请求很多都喜欢配置拦截器，生成专属request方法，通过设置请求拦截器注入token，设置响应拦截器对响应作出响应的处理，比如报错信息，这样就不需要每次在catch里去提示错误信息了</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    import axios from &quot;axios&quot;;    import router from &#39;@/router/index.js&#39;;    import &#123; Message &#125; from &quot;element-ui&quot;;    import &#123; getToken, removeToken &#125; from &#39;@/utils/auth&#39;    const service = axios.create(&#123;    timeout: 20000 // 请求超时时间    &#125;);    // request拦截器，    service.interceptors.request.use(    config =&gt; &#123;        // 权限校验        var sysToken = getToken();        if (sysToken &amp;&amp; sysToken.length &gt; 0) &#123;        config.headers[&#39;Authorization&#39;] = sysToken        &#125;        return config;    &#125;,    error =&gt; &#123;        return Promise.reject(error);    &#125;    );    // response拦截器，    service.interceptors.response.use(    response =&gt; &#123;        if (response.config.responseType === &#39;blob&#39;) &#123;        if (response.status != 200) &#123;            Message.error(&#39;请求失败&#39; + response.status);            return Promise.reject()        &#125; else if (!response.headers[&quot;content-disposition&quot;]) &#123;            Message.error(&#39;暂无接口访问权限&#39;);            return Promise.reject()        &#125;        return response        &#125; else &#123;        if (response.data.code !== 0) &#123;            let errMsg = response.data.msg;            if (response.data.code == 401) &#123; // token失效            if (getToken()) &#123;                Message.error(errMsg);                removeToken()                router.replace(&#39;/Login&#39;)            &#125;            &#125; else &#123;            Message.error(errMsg);            &#125;            return Promise.reject(errMsg)        &#125;        return response.data;        &#125;    &#125;,    error =&gt; &#123;        Message.error(&#39;请求服务器失败&#39;);        return Promise.reject(error);    &#125;    );    export default service</code></pre>]]></content>
      
      
      <categories>
          
          <category> Axios </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态生成vue路由</title>
      <link href="/2022/09/29/vue-makeRoutes/"/>
      <url>/2022/09/29/vue-makeRoutes/</url>
      
        <content type="html"><![CDATA[<h3 id="动态生成vue路由"><a href="#动态生成vue路由" class="headerlink" title="动态生成vue路由"></a>动态生成vue路由</h3><p><strong>ps:</strong> <em>实现动态路由，通过后端返回的菜单，然后<code>addRoutes</code>进行动态生成vue的路由，详情：<a href="https://www.cnblogs.com/shaoyunfeng93/p/16266729.html">https://www.cnblogs.com/shaoyunfeng93/p/16266729.html</a></em></p><h4 id="vue-Code"><a href="#vue-Code" class="headerlink" title="vue Code"></a>vue Code</h4><p>因为在路由中存在毫无实意的父级目录，所以需要有个<code>router-view</code>来承接子页面的展示</p><pre><code class="vue">// RouterView组件&lt;template&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><p>动态生成路由需要和后端开发人员约定好配置的参数,而且<em>后端配置的url需要和前端文件的目录结构一致</em>…<br>用来处理后端返回的菜单拼接成<code>vue-router</code>的格式, 该vue项目是根据<code>vue-admin-template</code>模板<strong>二次开发</strong>的…</p><pre><code class="js">  // 加载视图组件  function loadView(componentUrl) &#123;      return resolve =&gt; require.ensure([], () =&gt; resolve(require(&#39;@/views&#39; + componentUrl)))  &#125;  // 递归构造路由  function buildRoutes(routes) &#123;      return routes.map(route =&gt; &#123;          let _route = &#123;&#125;;          let meta = &#123;              title: route.name,              icon: route.icon,          &#125;;          if (route.type == 1) &#123; // 目录              _route.component = route.parentId == 0 ? Layout : RouterView;              if (route.children &amp;&amp; route.children[0]) &#123;                  _route.redirect = route.children[0].path;              &#125;          &#125; else if (route.type == 2) &#123; // 菜单              _route.component = loadView(route.url)              meta.actionButtonList = route.children || [];          &#125;          return &#123;              path: route.url,              name: route.code,              ..._route,              meta,              children: route.type == 1 ? buildRoutes(route.children || []) : [], // 只有目录才去在构造children路由          &#125;      &#125;)  &#125;  // 递归过滤掉有重定向却没有children的父级路由  function filterAsyncRoutes(routes) &#123;      routes = routes.filter(d =&gt; &#123;          return d.type != 1 || (d.children &amp;&amp; d.children.length &gt; 0)      &#125;)      routes.forEach(route =&gt; &#123;          if (route.children &amp;&amp; route.children.length &gt; 0) &#123;              route.children = filterAsyncRoutes(route.children)          &#125;      &#125;)      return routes  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监听用户返回页面</title>
      <link href="/2022/09/29/js-listenUserBack/"/>
      <url>/2022/09/29/js-listenUserBack/</url>
      
        <content type="html"><![CDATA[<h3 id="监听用户返回页面"><a href="#监听用户返回页面" class="headerlink" title="监听用户返回页面"></a>监听用户返回页面</h3><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><p>在h5支付页面完成后，需要判断用户返回再去请求后端接口是否支付成功，在进行后续步骤…</p><h4 id="code-Explain"><a href="#code-Explain" class="headerlink" title="code Explain"></a>code Explain</h4><p>这边就只展示解决兼容移动端浏览器去请求后端是否支付订单的步骤；</p><p>解释一下为啥使用两种监听事件，还有为啥要用sessionStorage去存储sign_paying这个是否支付中状态</p><p>在一些移动端浏览器中，各个浏览器五花八门，一些浏览器的行为也千姿百态，</p><p>在ios的safari浏览器中，前进后退是走缓存的，安卓浏览器中一些走缓存一些不走缓存，如果不用localStorage存储状态每次前进后退会导致sign_paying一直都被重置为false，导致不去请求支付结果接口，从而导致不执行支付成功或失败的逻辑</p><p>pageshow事件是不管页面走不走缓存都会触发的window事件，页面刷新也会执行，也就是说只要来到这个页面就执行，但是后台挂起在打开不执行</p><p>visibilitychange事件将后台挂起在打开会执行，</p><p>正如上面所说的各个浏览器心怀鬼胎，我们都猜不到他们的行为是如何的，在拉起支付宝（针对原生支付）的行为上也不太清楚，就我测试的ios是直接跳到新的页面在提示拉起（产生前进&#x2F;后退），在安卓上有的也是跳到新的页面在提示拉起（产生前进&#x2F;后退），有的直接在当前页就直接提示拉起（不产生前进&#x2F;后退）；</p><p>因此同时监听上2个事件，并在监听事件里加上httpCount:0时才能执行httpQueryOrderPay， signStack是用来限制只走一遍查询，因为2个监听可能同时都会执行httpQueryOrderPay</p><p>还有一点就是可能有人会觉得奇怪为什么把httpQueryOrderPay用setTimeout变为异步， 因为在部分手机（在我测试来看 三星默认浏览器存在这个问题）会导致ajax请求xhr.status返回0，导致直接走到error；具体原因我也不太清楚T_T，但是只要异步一下就OK了。</p><p>这些也只是为了知道啥时候才去请求支付结果接口，不然也大可以直接在页面一展示就去请求轮询，但是对服务器压力太大~</p><p><strong>ps:</strong> <em>以下其实是vue的代码…勉强看一下…</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    // visibilityChange事件兼容性写法    var hidden, visibilityChange;    if (typeof document.hidden !== &quot;undefined&quot;) &#123; // Opera 12.10 and Firefox 18 and later support        hidden = &quot;hidden&quot;;        visibilityChange = &quot;visibilitychange&quot;;    &#125; else if (typeof document.msHidden !== &quot;undefined&quot;) &#123;        hidden = &quot;msHidden&quot;;        visibilityChange = &quot;msvisibilitychange&quot;;    &#125; else if (typeof document.webkitHidden !== &quot;undefined&quot;) &#123;        hidden = &quot;webkitHidden&quot;;        visibilityChange = &quot;webkitvisibilitychange&quot;;    &#125;    // 监听用户返回页面的事件    if (sessionStorage.getItem(&#39;qyyz_paying&#39;) == &#39;true&#39;) &#123;        this.signStack.push(&#39;reload&#39;)        this.httpQueryOrderPay(&#39;reload&#39;);    &#125;    window.addEventListener(&#39;pageshow&#39;, this.pageShow, false);    document.addEventListener(visibilityChange, this.visibilityChange, false);    // 参数说明： httpCount: 请求是否支付的接口次数, httpQueryOrderPay根据自己的接口逻辑来替换，    methods: &#123;        pageShow() &#123;            if (sessionStorage.getItem(&#39;sign_paying&#39;) == &#39;true&#39;) &#123; // 是否支付中                // 轮询是否支付了            this.signStack.push(&#39;pageShow&#39;);                setTimeout(() =&gt; &#123;                    this.httpQueryOrderPay(&#39;pageShow&#39;);                &#125;, 0)            &#125;        &#125;,        visibilityChange() &#123;            if (!document[hidden]) &#123;                if (sessionStorage.getItem(&#39;sign_paying&#39;) == &#39;true&#39;) &#123; // 是否支付中                    // 轮询是否支付了                this.signStack.push(&#39;visibilityChange&#39;);                    setTimeout(() =&gt; &#123;                        this.httpQueryOrderPay(&#39;visibilityChange&#39;);                    &#125;, 0)                &#125;            &#125;        &#125;,        httpQueryOrderPay(type) &#123;            if (type !== this.signStack[0]) &#123; // 谁最先执行就走哪个                return;            &#125;            this.httpCount++;            ajax(&#123;                url: &#39;查询订单支付结果的接口&#39;,                type: &#39;get&#39;,                data: &#123;                    orderId: 订单id                &#125;,                success: res =&gt; &#123;                    if (res.result) &#123;                        this.httpCount = 0;                        sessionStorage.setItem(&#39;sign_paying&#39;, false);                    &#125; else &#123;                        if (this.httpCount &lt; 3) &#123; // 轮询不超过3次                            setTimeout(() =&gt; &#123;                                this.httpQueryOrderPay(type);                            &#125;, 500)                        &#125; else if (this.httpCount == 3) &#123; // 轮询到第3次没有找到,则提示用户                            this.httpCount = 0;                            sessionStorage.setItem(&#39;sign_paying&#39;, false);                            // 挽留提示                        &#125;                    &#125;                &#125;,                //异常处理                error: e =&gt; &#123;                    this.httpCount = 0;                    sessionStorage.setItem(&#39;sign_paying&#39;, false);                &#125;            &#125;)        &#125;,    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js手写函数</title>
      <link href="/2022/09/29/js-handWriteFunc/"/>
      <url>/2022/09/29/js-handWriteFunc/</url>
      
        <content type="html"><![CDATA[<h3 id="js手写函数"><a href="#js手写函数" class="headerlink" title="js手写函数"></a>js手写函数</h3><p><strong>ps:</strong> <em>好像面试的时候都喜欢让手写 …</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    // url的queryString转成对象    function queryStr2Obj(url) &#123;        const query = &#123;&#125;;        const search = url.split(&#39;?&#39;)[1];        if (!search) &#123;            return &#123;&#125;        &#125;        search.split(&#39;&amp;&#39;).forEach(item =&gt; &#123;            let [key, value] = item.replace(&#39;=&#39;, &#39;:&#39;).split(&#39;:&#39;);            query[key] = decodeURIComponent(value);        &#125;);        return query;    &#125;    // list数组转tree数组    const currentArray = [        &#123; id: &quot;01&quot;, name: &quot;张大大&quot;, pid: &quot;&quot;, job: &quot;项目经理&quot; &#125;,        &#123; id: &quot;02&quot;, name: &quot;小亮&quot;, pid: &quot;01&quot;, job: &quot;产品leader&quot; &#125;,        &#123; id: &quot;03&quot;, name: &quot;小美&quot;, pid: &quot;01&quot;, job: &quot;UIleader&quot; &#125;,        &#123; id: &quot;04&quot;, name: &quot;老马&quot;, pid: &quot;01&quot;, job: &quot;技术leader&quot; &#125;,        &#123; id: &quot;05&quot;, name: &quot;老王&quot;, pid: &quot;01&quot;, job: &quot;测试leader&quot; &#125;,        &#123; id: &quot;06&quot;, name: &quot;老李&quot;, pid: &quot;01&quot;, job: &quot;运维leader&quot; &#125;,        &#123; id: &quot;07&quot;, name: &quot;小丽&quot;, pid: &quot;02&quot;, job: &quot;产品经理&quot; &#125;,        &#123; id: &quot;08&quot;, name: &quot;大光&quot;, pid: &quot;02&quot;, job: &quot;产品经理&quot; &#125;,        &#123; id: &quot;09&quot;, name: &quot;小高&quot;, pid: &quot;03&quot;, job: &quot;UI设计师&quot; &#125;,        &#123; id: &quot;10&quot;, name: &quot;小刘&quot;, pid: &quot;04&quot;, job: &quot;前端工程师&quot; &#125;,        &#123; id: &quot;11&quot;, name: &quot;小华&quot;, pid: &quot;04&quot;, job: &quot;后端工程师&quot; &#125;,        &#123; id: &quot;12&quot;, name: &quot;小李&quot;, pid: &quot;04&quot;, job: &quot;后端工程师&quot; &#125;,        &#123; id: &quot;13&quot;, name: &quot;小赵&quot;, pid: &quot;05&quot;, job: &quot;测试工程师&quot; &#125;,        &#123; id: &quot;14&quot;, name: &quot;小强&quot;, pid: &quot;05&quot;, job: &quot;测试工程师&quot; &#125;,        &#123; id: &quot;15&quot;, name: &quot;小涛&quot;, pid: &quot;06&quot;, job: &quot;运维工程师&quot; &#125;    ];    function list2tree(list, pid) &#123;        let children = list.filter(item =&gt; item.pid == pid);        return children.map(item =&gt; &#123;            item.children = list2tree(list, item.id);            return item;        &#125;)    &#125;    // tree数组转list数组    function tree2list(tree) &#123;        const list = [], queue = [...tree];        while (queue.length) &#123;            let &#123; children, ...node &#125; = queue.shift();            if (children) &#123;                queue.push(...children)            &#125;            list.push(node)        &#125;        return list;    &#125;    // 多维数组，每每元素组合，不重复    /*    * 如： arr =  [[1,2],[3,4]]  =&gt; combination(arr) =&gt; [[1,3],[1,4],[2,3],[2,4]]    */    function combination(arr) &#123;        const ary = [];        const store = [];        const fn = function (i = 0) &#123;            for (let j = 0; j &lt; arr[i].length; j++) &#123;                if (i &lt; arr.length - 1) &#123;                    store[i] = arr[i][j];                    fn(i + 1)                &#125; else &#123;                    ary.push([...store, arr[i][j]])                &#125;            &#125;        &#125;        fn();        return ary;    &#125;    // 函数柯里化（思路：递归收集参数，参数刚好时调用原函数）    function curry(fn, args = []) &#123;        return (...arg) =&gt; &#123;            let _arg = args.concat(arg)            if (_arg.length != fn.length) &#123;                return curry(fn, _arg)            &#125; else &#123;                return fn(..._arg)            &#125;        &#125;    &#125;    // 节流    function throttle(fn, delay) &#123;        // 重置定时器        let timer = null;        // 返回闭包函数        return function () &#123;            // 记录事件参数            let args = arguments;            // 如果定时器为空            if (!timer) &#123;                // 开启定时器                timer = setTimeout(() =&gt; &#123;                    // 执行函数                    fn.apply(this, args);                    // 函数执行完毕后重置定时器                    timer = null;                &#125;, delay);            &#125;        &#125;    &#125;    // 防抖    function debounce(fn, delay = 500) &#123;        // timer是一个定时器        let timer = null;        // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器        return function () &#123;            // 保存事件参数，防止fn函数需要事件参数里的数据            let arg = arguments;            // 调用一次就清除上一次的定时器            clearTimeout(timer);            // 开启这一次的定时器            timer = setTimeout(() =&gt; &#123;                // 若不改变this指向，则会指向fn定义环境                fn.apply(this, arg);            &#125;, delay)        &#125;    &#125;    // call    function mycall(that, ...args) &#123;        that = that == null ? window : new Object(that)        that.fn = this;        that.fn(...args);        delete that.fn;    &#125;    Function.prototype.mycall = mycall    // apply    function myapply(that, args) &#123;        that = that == null ? window : new Object(that)        that.fn = this;        that.fn(...args);        delete that.fn;    &#125;    Function.prototype.myapply = myapply    // bind    function mybind(that) &#123;        let fn = this;        return function (...args) &#123;            fn.apply(that, args);        &#125;    &#125;    Function.prototype.mybind = mybind    // new    function myNew(fn, ...args) &#123;        let obj = Object.create(fn.prototype);        fn.apply(obj, args);        return obj;    &#125;    // instanceof实现    function instanceOf(origin, target) &#123;        while (1) &#123;            if (origin.__proto__ == target.prototype) &#123;                return true            &#125;            if (origin.__proto__ == null) &#123;                return false            &#125;            origin = origin.__proto__        &#125;    &#125;    // 数组乱序    function shuffle(arr) &#123;        let len = arr.length;        for (let i = 0; i &lt; len - 1; i++) &#123;            let index = parseInt(Math.random() * (len - i));            let temp = arr[index];            arr[index] = arr[len - i - 1];            arr[len - i - 1] = temp;        &#125;        return arr;    &#125;    // 随机字串    function randomString(len) &#123;        len = len || 8;        let $chars = &#39;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#39;;    /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/        let maxPos = $chars.length;        let str = &#39;&#39;;        for (let i = 0; i &lt; len; i++) &#123;            str += $chars.charAt(Math.floor(Math.random() * maxPos));        &#125;        return str;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现对象深拷贝函数</title>
      <link href="/2022/09/29/js-deepClone/"/>
      <url>/2022/09/29/js-deepClone/</url>
      
        <content type="html"><![CDATA[<h3 id="实现对象深拷贝函数"><a href="#实现对象深拷贝函数" class="headerlink" title="实现对象深拷贝函数"></a>实现对象深拷贝函数</h3><p><strong>ps:</strong> <em><code>深拷贝</code>需要根据不同的类型值进行不同的拷贝特性,Reg对象的一些属性拷贝，</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    // 判断是否是某类型    const isType = (obj, type) =&gt; &#123;        if (typeof obj !== &#39;object&#39;) return false;        const typeString = Object.prototype.toString.call(obj);        let flag;        switch (type) &#123;            case &#39;Array&#39;:            flag = typeString === &#39;[object Array]&#39;;            break;            case &#39;Date&#39;:            flag = typeString === &#39;[object Date]&#39;;            break;            case &#39;RegExp&#39;:            flag = typeString === &#39;[object RegExp]&#39;;            break;            default:            flag = false;        &#125;        return flag;        &#125;;        // 获取到正则修饰符        const getRegExp = re =&gt; &#123;        var flags = &#39;&#39;;        if (re.global) flags += &#39;g&#39;;        if (re.ignoreCase) flags += &#39;i&#39;;        if (re.multiline) flags += &#39;m&#39;;        return flags;        &#125;;        // 深度克隆        const deepClone = parent =&gt; &#123;        // 旧对象 ：新对象 map        let _map = new WeakMap();                const _clone = parent =&gt; &#123;            if (parent === null) return null;            if (typeof parent !== &#39;object&#39;) return parent;            if (_map.get(parent)) return _map.get(parent);                        let newParent;            if (isType(parent, &#39;Array&#39;)) &#123;                // 对数组做特殊处理                newParent = [];            &#125; else if (isType(parent, &#39;RegExp&#39;)) &#123;                // 对正则对象做特殊处理                newParent = new RegExp(parent.source, getRegExp(parent));                if (parent.lastIndex) &#123;                    newParent.lastIndex = parent.lastIndex;                &#125;            &#125; else if (isType(parent, &#39;Date&#39;)) &#123;                // 对Date对象做特殊处理                newParent = new Date(parent.getTime());            &#125; else &#123;                // 处理对象原型                newParent = Object.create(parent.__proto__);            &#125;                        // 把索引对象存储，原来对象：拷贝后的对象，可能内部会互相引用            _map.set(parent, newParent);            for (let i in parent) &#123;                // 递归                newParent[i] = _clone(parent[i]);            &#125;                    return newParent;        &#125;;        return _clone(parent);    &#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>照猫画虎之实现Promise</title>
      <link href="/2022/09/29/js-promiseDemo/"/>
      <url>/2022/09/29/js-promiseDemo/</url>
      
        <content type="html"><![CDATA[<h3 id="照猫画虎之实现Promise"><a href="#照猫画虎之实现Promise" class="headerlink" title="照猫画虎之实现Promise"></a>照猫画虎之实现Promise</h3><p><strong>ps:</strong> <em>简单的模拟实现一下<code>Promise</code>，好像只是行到意不到…hhh~</em></p><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">  // promise(丑陋的)    class UglyPromise &#123;        constructor(callback)&#123;            this.status = &#39;pending&#39;            this.value = undefined            this.sucessCb = []            this.failedCb = []                        const resolve = value =&gt; &#123;            if(this.status === &#39;pending&#39;)&#123;                this.status = &#39;success&#39;                this.value = value                this.sucessCb.forEach(fn =&gt; &#123;                fn(value)                &#125;)            &#125;            &#125;                        const reject = value =&gt; &#123;            if(this.status === &#39;pending&#39;)&#123;                this.status = &#39;failed&#39;                this.value = value                this.failedCb.forEach(fn =&gt; &#123;                fn(value)                &#125;)            &#125;            &#125;                        try &#123;            callback(resolve, reject)            &#125; catch(e) &#123;            reject(e)            &#125;        &#125;            then(successCb, failedCb)&#123;                        if(typeof successCb === &#39;function&#39;)&#123;            if(this.status == &#39;pending&#39;)&#123;                this.sucessCb.push(successCb)            &#125;else&#123;                successCb(this.value)            &#125;            &#125;            if(typeof failedCb === &#39;function&#39;)&#123;                        if(this.status == &#39;pending&#39;)&#123;                this.failedCb.push(failedCb)            &#125;else&#123;                failedCb(this.value)            &#125;            &#125;                        return this        &#125;                catch(failedCb)&#123;            if(typeof failedCb === &#39;function&#39;)&#123;            if(this.status == &#39;pending&#39;)&#123;                this.failedCb.push(failedCb)            &#125;else&#123;                failedCb(this.value)            &#125;            &#125;        &#125;            &#125;     UglyPromise.resolve = value =&gt;&#123;        return new UglyPromise(rev =&gt; &#123;        rev(value)        &#125;)    &#125;        UglyPromise.race = arr =&gt;&#123;        return new MyPromise((rev,rej) =&gt; &#123;        for(let i = 0;i &lt; arr.length;i++)&#123;            arr[i].then(res =&gt; &#123;            rev(res)            &#125;).catch(e =&gt; &#123;            rej(e)            &#125;)        &#125;        &#125;)    &#125;        UglyPromise.all = arr =&gt;&#123;        let length = arr.length;        let count = 0;        let result = new Array(length);        if(length == 0)&#123;            return UglyPromise.resolve()        &#125;        return new UglyPromise((rev,rej) =&gt; &#123;        for(let i = 0;i&lt;arr.length;i++)&#123;            arr[i].then(res =&gt; &#123;            result[i] = res // 为了结果顺序与开始顺序一致            if(++count == length)&#123;                rev(result)            &#125;            &#125;).catch(e =&gt; &#123;            rej(e)            &#125;)        &#125;        &#125;)    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现Demo之CSS3d多面体</title>
      <link href="/2022/09/28/html-css3Multilateral/"/>
      <url>/2022/09/28/html-css3Multilateral/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS3d多面体"><a href="#CSS3d多面体" class="headerlink" title="CSS3d多面体"></a>CSS3d多面体</h3><p><strong>ps:</strong> <em>简单探索css3的3d属性，制作一个立体的多面体结构的自动轮播，可以根据手势进行左右拖拽，简易Demo如下</em></p><h4 id="css-Code"><a href="#css-Code" class="headerlink" title="css Code"></a>css Code</h4><pre><code class="css">    /*n边形的外角和为360  360/n            n变形的内角 180 - 360/n*/    * &#123;        margin: 0;        padding: 0;    &#125;    html,    body &#123;        background-image: radial-gradient(#fff, #000);        height: 100%;        overflow: hidden;    &#125;    #wrap &#123;        position: absolute;        left: 0;        top: 0;        right: 0;        bottom: 0;        margin: auto;        width: 300px;        height: 300px;        /*border: 1px solid;*/        perspective: 1000px;        user-select: none;    &#125;    #wrap&gt;.box &#123;        position: absolute;        left: 0;        top: 0;        right: 0;        bottom: 0;        margin: auto;        width: 300px;        height: 300px;        transition: 10s transform;        transform-style: preserve-3d;        animation-name: rotate;        animation-duration: 48s;        animation-timing-function: linear;        animation-iteration-count: infinite;        animation-fill-mode: forwards;    &#125;    #wrap&gt;.box&gt;div &#123;        position: absolute;        width: 300px;        height: 300px;        background: rgba(0, 0, 0, 0.1);        text-align: center;        font: 50px/300px &quot;微软雅黑&quot;;        backface-visibility: visible;    &#125;    @keyframes rotate &#123;        form &#123;            transform: rotateY(var(--beginDeg));        &#125;        to &#123;            transform: rotateY(var(--endDeg));        &#125;    &#125;    #wrap:hover&gt;.box &#123;        animation-play-state: paused;    &#125;</code></pre><h4 id="html-Code"><a href="#html-Code" class="headerlink" title="html Code"></a>html Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;CSS3d多面体&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;--beginDeg:0deg;--endDeg:360deg;&quot;&gt;    &lt;div id=&quot;wrap&quot;&gt;        &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">   //n：棱数    window.onload = function () &#123;        createLZ(11);        var down = false;        var startX = 0;        var baseRotate = 0;        var currentRotate = 0;        var wrap = document.getElementById(&#39;wrap&#39;);        var body = document.body;        var boxNode = document.querySelector(&quot;#wrap &gt; .box&quot;);        // wrap元素鼠标按下滑动事件        wrap.onmousedown = function (e) &#123;            down = true            startX = e.clientX;        &#125;        wrap.onmousemove = function (e) &#123;            if (down) &#123;                currentRotate = baseRotate + (e.clientX - startX) / 10;                boxNode.style.transform = &quot;rotateY(&quot; + currentRotate + &quot;deg)&quot;;            &#125;        &#125;        window.onmouseup = function (e) &#123;            baseRotate = currentRotate;            down = false;            body.style.cssText = &quot;--beginDeg:&quot; + currentRotate + &quot;deg;--endDeg:&quot; + (currentRotate + 360) + &quot;deg;&quot;;        &#125;    &#125;    function createLZ(n) &#123;        var boxNode = document.querySelector(&quot;#wrap &gt; .box&quot;);        var stlyleNode = document.createElement(&quot;style&quot;);        //外角        var degOut = 360 / n;        //内角        var degIn = 180 - 360 / n;        var text = &quot;&quot;;        var cssText = &quot;&quot;;        for (var i = 0; i &lt; n; i++) &#123;            text += &quot;&lt;div&gt;&lt;/div&gt;&quot;;            cssText += `#wrap &gt; .box &gt; div:nth-child($&#123;i + 1&#125;)&#123;transform: rotateY($&#123;i * degOut&#125;deg);background: url(./img/$&#123;i&#125;.jpeg) center no-repeat;&#125;`;        &#125;        boxNode.innerHTML = text;        var mianNode = document.querySelector(&quot;#wrap &gt; .box &gt; div&quot;);        //棱长        var length = mianNode.offsetWidth;        cssText += &quot;#wrap &gt; .box&#123;transform-origin: center center -&quot; + (length / 2 * Math.tan((degIn / 2) * Math.PI / 180)) + &quot;px;&#125;&quot;;        cssText += &quot;#wrap &gt; .box &gt; div&#123;transform-origin: center center -&quot; + (length / 2 * Math.tan((degIn / 2) * Math.PI / 180)) + &quot;px;&#125;&quot;;        stlyleNode.innerHTML = cssText;        document.head.appendChild(stlyleNode);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现Demo之H5幸运大转盘</title>
      <link href="/2022/09/28/html-lottery/"/>
      <url>/2022/09/28/html-lottery/</url>
      
        <content type="html"><![CDATA[<h3 id="H5幸运大转盘"><a href="#H5幸运大转盘" class="headerlink" title="H5幸运大转盘"></a>H5幸运大转盘</h3><p><strong>gitee地址: <a href="https://gitee.com/shaoyunfeng793/lucky-wheel">https://gitee.com/shaoyunfeng793/lucky-wheel</a></strong></p><h4 id="css-Code"><a href="#css-Code" class="headerlink" title="css Code"></a>css Code</h4><pre><code class="css">    * &#123;        margin: 0;        padding: 0;    &#125;    .container &#123;        background-image: url(./wheel-bodybg.png);        background-size: 100% 100%;        min-height: 100vh;        display: flex;        justify-content: center;        align-items: center;    &#125;    .wheel &#123;        width: 800px;        height: 800px;        position: relative;        background-image: url(./wheel-bg.png);        background-size: 100% 100%;        display: flex;        justify-content: center;        align-items: center;    &#125;    .wheel-light &#123;        background-image: url(./wheel-bg2.png) !important;    &#125;    #wheelCanvas &#123;        width: 700px;        height: 700px;    &#125;    .transition &#123;        transition: all 2s;    &#125;    .pointer &#123;        display: block;        position: absolute;        width: 200px;        height: 200px;        background-color: transparent;        background-image: url(./wheel-pointer.png);        background-repeat: no-repeat;        background-size: contain;        background-position: center;        border: none;        outline: none;    &#125;    .pointer-animation &#123;        animation: scale 1s infinite linear alternate;    &#125;    @keyframes scale &#123;        0% &#123;            transform: scale(1);        &#125;        100% &#123;            transform: scale(1.1);        &#125;    &#125;</code></pre><h4 id="html-Code"><a href="#html-Code" class="headerlink" title="html Code"></a>html Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;域叶&quot;&gt;    &lt;title&gt;幸运大转盘&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./alert.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;preloadImg1&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;preloadImg2&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;wheel&quot;&gt;            &lt;canvas id=&quot;wheelCanvas&quot; width=&quot;600px&quot; height=&quot;600px&quot;&gt;&lt;/canvas&gt;            &lt;button class=&quot;pointer pointer-animation&quot; id=&quot;getAward&quot;&gt;&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./alert.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    //抽奖转盘    var turnWheel = &#123;        reaward: [            &#123; name: &#39;沙雕老二达&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065206471_siCEaEpi.jpg&#39; &#125;,            &#123; name: &#39;憨憨狐狸&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065297220_maYiZc27.jpg&#39; &#125;,            &#123; name: &#39;鸡太美阿坤&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065313260_JDMZ2GTW.jpg&#39; &#125;,            &#123; name: &#39;色情狂魔辉&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065328906_azt6pQD2.jpg&#39; &#125;,            &#123; name: &#39;海王牛头人&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065383539_rBYtb5BJ.jpg&#39; &#125;,            // &#123; name: &#39;高冷男神流川&#39;, icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065369843_rny7mahE.jpg&#39; &#125;,        ], //转盘奖品        colors: [], //转盘奖品区块对应背景颜色        fontColor: &#39;#8C42E9&#39;, //转盘奖品字体颜色        radius: 300, //转盘半径        textRadius: 320, //转盘奖品位置距离圆心的距离    &#125;;    var timer = null;    var turning = false;    var wheelCanvas = document.getElementById(&quot;wheelCanvas&quot;);    turnWheel.reaward = turnWheel.reaward.map(d =&gt; &#123;        let img = new Image();        img.src = d.icon;        d.iconImg = img        return d    &#125;)    turnWheel.colors = [        &quot;#eecffe&quot;,        &quot;#FFFFFF&quot;,        &quot;#eecffe&quot;,        &quot;#FFFFFF&quot;,        &quot;#eecffe&quot;,        &quot;#FFFFFF&quot;,    ];    window.onload = function () &#123;        drawWheelCanvas(&#39;wheelCanvas&#39;, turnWheel, 700, 700);        var getAward = document.getElementById(&quot;getAward&quot;);        var index = 0; // 中奖将品的数组下标        getAward.addEventListener(&quot;click&quot;, function () &#123;            if (turning) &#123;                return;            &#125;            turning = true;            index = Math.floor(Math.random() * turnWheel.reaward.length);            wheelCanvas.classList.add(&quot;transition&quot;);            twinkle(() =&gt; &#123;                smoke.alert(`&lt;p&gt;恭喜抽到$&#123;turnWheel.reaward[index].name&#125;&lt;/p&gt;&lt;img style=&quot;width:200px;margin-top:10px&quot; src=&quot;$&#123;turnWheel.reaward[index].icon&#125;&quot; /&gt;`,//第一个参数提示内容                    function () &#123;                        wheelCanvas.style.transform = &#39;rotate(0deg)&#39;;                    &#125;,//第二个参数回调函数                    &#123; ok: &quot;确定&quot; &#125;);//第三个参数按钮的属性            &#125;);            rotateWheel(index, turnWheel.reaward.length)        &#125;)    &#125;;    // 转盘灯闪烁 callback为抽奖结果后执行函数    function twinkle(callback) &#123;        let wheel = document.querySelector(&#39;.wheel&#39;);        let pointer = document.querySelector(&#39;.pointer&#39;);        pointer.classList.remove(&#39;pointer-animation&#39;);        timer = setInterval(() =&gt; &#123;            wheel.classList.toggle(&#39;wheel-light&#39;);        &#125;, 200);        setTimeout(() =&gt; &#123;            turning = false;            wheelCanvas.classList.remove(&#39;transition&#39;);            wheel.classList.remove(&#39;wheel-light&#39;);            pointer.classList.add(&#39;pointer-animation&#39;);            timer &amp;&amp; clearInterval(timer);            typeof callback === &#39;function&#39; &amp;&amp; callback();        &#125;, 2000);    &#125;    // 获取像素比 高清cavas    function getPixelRatio(context) &#123;        var backingStore = context.backingStorePixelRatio ||            context.webkitBackingStorePixelRatio ||            context.mozBackingStorePixelRatio ||            context.msBackingStorePixelRatio ||            context.oBackingStorePixelRatio ||            context.backingStorePixelRatio || 1;        return (window.devicePixelRatio || 1) / backingStore;    &#125;;    // 旋转转盘 (index:中奖将品的数组下标)    function rotateWheel(awardIndex, awardCount) &#123;        let baseAngle = 360 / awardCount;        let rotateRound = 360 * 5; // 每次旋转5圈        wheelCanvas.style.transform = &#39;rotate(&#39; + ((360 - (baseAngle * awardIndex)) + rotateRound) + &#39;deg)&#39;;    &#125;    // 绘制转盘    function drawWheelCanvas(canvasId, turnWheel, _w = 700, _h = 700) &#123;        let canvas = document.getElementById(canvasId);        let baseAngle = Math.PI * 2 / (turnWheel.reaward.length);        let ctx = canvas.getContext(&quot;2d&quot;);        let _ratio = getPixelRatio(ctx);        let canvasW = canvas.width = _w * _ratio;// 画板的高度        let canvasH = canvas.height = _h * _ratio; // 画板的宽度        canvas.style.width = _w + &#39;px&#39;;        canvas.style.height = _h + &#39;px&#39;;        ctx.scale(_ratio, _ratio); // 需要在放大同等倍数，因为画布的大小是实际渲染的3倍也就是被缩小了        ctx.fillStyle = &quot;#fff000&quot;;        ctx.clearRect(0, 0, canvasW, canvasH);//去掉背景默认的黑色        ctx.font = &#39;26px Microsoft YaHei&#39;;        for (let index = 0; index &lt; turnWheel.reaward.length; index++) &#123;            let angle = index * baseAngle - baseAngle / 2 - Math.PI / 2;            let rewardName = turnWheel.reaward[index].name;            let translateX = _w * 0.5 + Math.cos(angle + baseAngle / 2) * turnWheel.textRadius;            let translateY = _h * 0.5 + Math.sin(angle + baseAngle / 2) * turnWheel.textRadius;            ctx.fillStyle = turnWheel.colors[index];            ctx.beginPath();            ctx.arc(_w * 0.5, _h * 0.5, Math.min(_w / 2, _h / 2), angle, angle + baseAngle, false);            ctx.lineTo(_w * 0.5, _h * 0.5);            ctx.fill();            ctx.save();            ctx.fillStyle = turnWheel.fontColor;            ctx.translate(translateX, translateY);            ctx.rotate(angle + baseAngle / 2 + Math.PI / 2);            ctx.fillText(rewardName, -ctx.measureText(rewardName).width / 2, 100);            //添加对应图标            if (turnWheel.reaward[index] &amp;&amp; turnWheel.reaward[index].icon) &#123;                ctx.drawImage(turnWheel.reaward[index].iconImg, -40, 140, 80, 80);            &#125;            ctx.restore(); //很关键        &#125;    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现图片懒加载</title>
      <link href="/2022/09/28/html-imgLazyLoad/"/>
      <url>/2022/09/28/html-imgLazyLoad/</url>
      
        <content type="html"><![CDATA[<h3 id="实现图片懒加载"><a href="#实现图片懒加载" class="headerlink" title="实现图片懒加载"></a>实现图片懒加载</h3><p><strong>ps:</strong> <em>简单探索下<code>IntersectionObserver</code>这个api，可以监听元素是否出现在可视窗口，利用这个特性以及dataset实现图片懒加载,简易Demo如下</em></p><h4 id="html-Code"><a href="#html-Code" class="headerlink" title="html Code"></a>html Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;title&gt;&lt;/title&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;style&gt;            ul&#123;                list-style: none;            &#125;            img&#123;                width: 200px;                height: 200px;                background: #ddd;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;ul&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2943125063,3292210397&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2024373923,2140139723&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097108640&amp;di=85ad12ff7eb7f9572016612de1135925&amp;imgtype=0&amp;src=http%3A%2F%2Fa-ssl.duitang.com%2Fuploads%2Fitem%2F201407%2F18%2F20140718063817_s3Gnz.gif&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097122497&amp;di=1dff2a1a87c795199973d6f351ab88c6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D1120712552%2C1362700559%26fm%3D214%26gp%3D0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097135282&amp;di=bbb17f186fa620e910ad079e5f998711&amp;imgtype=0&amp;src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D2230676464%2C2378994766%26fm%3D214%26gp%3D0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097163421&amp;di=8cd014f555709f796fe643adde44afc3&amp;imgtype=0&amp;src=http%3A%2F%2Fb.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fa044ad345982b2b7014e90fe33adcbef76099b33.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097184425&amp;di=4dbac84b3f735da758433becd9d4e9ee&amp;imgtype=0&amp;src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201407%2F13%2F20140713000933_dC2z3.thumb.700_0.gif&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097216523&amp;di=e3393b6449183d29f689e10783c9694b&amp;imgtype=0&amp;src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fw%253d580%2Fsign%3D2b04e747fd1f4134e0370576151e95c1%2F05460b2442a7d933458f9ed7ad4bd11372f00167.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=149701518,1608548313&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2692023635,939588326&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=268907504,1715864470&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603097268873&amp;di=0ec97e5a4185af04869e5f150a1bf18d&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171129%2Ff510b6d293264e0cba3072353e5eb067.gif&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=366871761,2360018043&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3251940718,1404860427&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2476878483,4014399276&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2055680573,3089421073&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;       &lt;li&gt;&lt;img data-src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3926221861,1230045557&amp;fm=26&amp;gp=0.jpg&quot; &gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">  var imglist = document.querySelectorAll(&#39;img&#39;)  var observer = new IntersectionObserver(entries=&gt;&#123;      entries.forEach(entry=&gt;&#123;          if(entry.intersectionRatio&gt;0)&#123;              entry.target.src = entry.target.dataset.src              observer.unobserve(entry.target)          &#125;      &#125;)  &#125;)  imglist.forEach(imgitem=&gt;&#123;      observer.observe(imgitem)  &#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出之拖拽事件</title>
      <link href="/2022/09/28/vue-exploreDrag/"/>
      <url>/2022/09/28/vue-exploreDrag/</url>
      
        <content type="html"><![CDATA[<h3 id="深入浅出之拖拽事件"><a href="#深入浅出之拖拽事件" class="headerlink" title="深入浅出之拖拽事件"></a>深入浅出之拖拽事件</h3><p><strong>ps:</strong> <em>简单探索下drag事件，把一些元素拉到目标区域，还可从目标区域拉回原来区域，简易Demo如下</em></p><h4 id="vue-Code"><a href="#vue-Code" class="headerlink" title="vue Code"></a>vue Code</h4><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;app-container&quot;&gt;    &lt;div class=&quot;table-container&quot;&gt;      &lt;el-row :gutter=&quot;20&quot;&gt;        &lt;el-col :span=&quot;4&quot;&gt;          &lt;div class=&quot;drag-from-zone&quot;&gt;            &lt;div              class=&quot;drag-item&quot;              v-for=&quot;(item, idx) in list&quot;              :key=&quot;idx&quot;              draggable=&quot;true&quot;              @dragstart=&quot;dragstart($event, item, idx)&quot;              @dragend=&quot;dragend($event)&quot;            &gt;              &#123;&#123; item.name &#125;&#125;            &lt;/div&gt;          &lt;/div&gt;        &lt;/el-col&gt;        &lt;el-col :span=&quot;20&quot;&gt;          &lt;div            id=&quot;target&quot;            @dragover=&quot;dragover($event)&quot;            @drop=&quot;drop($event)&quot;            class=&quot;drag-target-zone&quot;          &gt;            &lt;div              class=&quot;drag-item&quot;              v-for=&quot;(item, idx) in targetList&quot;              :key=&quot;idx&quot;              @dragstart=&quot;dragstart($event, item)&quot;              @dragend=&quot;dragend($event)&quot;            &gt;              &#123;&#123; item.name &#125;&#125;              &lt;i class=&quot;el-icon-close&quot; @click=&quot;removeItem(item)&quot;&gt;&lt;/i&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/el-col&gt;      &lt;/el-row&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var tmpData;export default &#123;  data() &#123;    return &#123;      list: [        &#123; id: 1, name: &quot;元素1&quot; &#125;,        &#123; id: 2, name: &quot;元素2&quot; &#125;,        &#123; id: 3, name: &quot;元素3&quot; &#125;,        &#123; id: 4, name: &quot;元素4&quot; &#125;,        &#123; id: 5, name: &quot;元素5&quot; &#125;,        &#123; id: 6, name: &quot;元素6&quot; &#125;,        &#123; id: 7, name: &quot;元素7&quot; &#125;,        &#123; id: 8, name: &quot;元素8&quot; &#125;,        &#123; id: 9, name: &quot;元素9&quot; &#125;,        &#123; id: 10, name: &quot;元素10&quot; &#125;,      ],      targetList: [],    &#125;;  &#125;,  methods: &#123;    dragstart(e, item) &#123;      //拖拽开始时将item存入vuex      console.log(&quot;拖拽开始 =&gt;&quot;, item);      tmpData = item;    &#125;,    dragend(e) &#123;      //拖拽结束执行的事件      console.log(&quot;拖拽结束 =&gt;&quot;, e);    &#125;,    dragover(e) &#123;      //拖拽在这个div里面拖拽时执行的事件      //一定要执行preventDefault(),否则drop事件不会被触发      e.preventDefault();    &#125;,    drop(e) &#123;      //在div里拖拽停止时执行的事件      this.list = this.list.filter((item) =&gt; item.id !== tmpData.id);      this.targetList.push(tmpData);    &#125;,    removeItem(data)&#123;      this.targetList = this.targetList.filter((item) =&gt; item.id !== data.id);      this.list.push(data);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.drag-from-zone &#123;  display: flex;  flex-direction: column;  align-items: center;&#125;.drag-item &#123;  display: inline-block;  padding: 10px 5px;  cursor: pointer;  border: 1px solid #ccc;  margin-bottom: 10px;&#125;.drag-target-zone &#123;  height: 500px;  border: 1px solid #ccc;&#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现Demo之滚动信息展示/弹幕</title>
      <link href="/2022/09/28/html-flutterAnimation/"/>
      <url>/2022/09/28/html-flutterAnimation/</url>
      
        <content type="html"><![CDATA[<h3 id="弹幕飘屏-amp-一个横框内的滚动信息展示"><a href="#弹幕飘屏-amp-一个横框内的滚动信息展示" class="headerlink" title="弹幕飘屏&amp;一个横框内的滚动信息展示"></a>弹幕飘屏&amp;一个横框内的滚动信息展示</h3><p><strong>ps:</strong> <em>实现一个展示给用户信息的横幅条，比如xxx购买了xxx产品真种滚屏信息或者弹幕效果，简易Demo如下</em></p><h4 id="html-Code"><a href="#html-Code" class="headerlink" title="html Code"></a>html Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Demo之滚动信息展示/弹幕&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 把选择器传入到下面的js函数中即可 --&gt;    &lt;div id=&quot;walk&quot;&gt;&lt;/div&gt;     &lt;div id=&quot;danmaku&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="js-Code-For-竖向滚动信息条"><a href="#js-Code-For-竖向滚动信息条" class="headerlink" title="js Code For 竖向滚动信息条"></a>js Code For 竖向滚动信息条</h4><pre><code class="js">    function Walk(&#123;    selector,    speed = 1,    data = [],    danweiLucheng,&#125;) &#123;    this.dom = document.querySelector(selector);    this.data = data;    this.speed = speed;    this.danweiLucheng = danweiLucheng;    this.timer = null;    this.init();    this.render();&#125;;Walk.prototype.render = function () &#123;    let htmlStr = &#39;&#39;;    this.data.concat(this.data[0]).forEach(d =&gt; &#123;        htmlStr += `&lt;div class=&quot;walking-item&quot;&gt;                        &lt;div class=&quot;walking-text&quot;&gt;$&#123;d.message&#125;&lt;/div&gt;                        &lt;img class=&quot;walking-img&quot;                            src=&quot;$&#123;d.icon&#125;&quot;&gt;                    &lt;/div&gt;`;    &#125;);    this.dom.innerHTML = htmlStr;&#125;;Walk.prototype.init = function () &#123;    this.index = 0;    this.lucheng = 0;    this.storeLucheng = 0;&#125;;Walk.prototype.playFrame = function () &#123;    setTimeout(() =&gt; &#123;        this.lucheng = this.storeLucheng;        this.timer = setInterval(() =&gt; &#123;            this.lucheng += this.speed;            this.dom.style.transform = `translate3d(0, -$&#123;this.lucheng&#125;px, 0)`;            if (this.lucheng - this.storeLucheng &gt;= this.danweiLucheng) &#123;                this.index++; //第一个动画结束，index下标下移                this.storeLucheng = this.lucheng;                if (this.index &gt;= this.data.length) &#123;                    this.dom.style.transform = &#39;translate3d(0, 0, 0)&#39;;                    this.init();                &#125;                clearInterval(this.timer);                this.playFrame();            &#125;        &#125;, 20)    &#125;, 1500)&#125;;</code></pre><h4 id="js-Code-For-弹幕"><a href="#js-Code-For-弹幕" class="headerlink" title="js Code For 弹幕"></a>js Code For 弹幕</h4><pre><code class="js">; (function () &#123;    var Danmaku = window.Danmaku = function (&#123;        selector,        data = [],        speed = 1,        itemWidth = 180,        itemHeigth = 30,        spaceWidth = 50,    &#125;) &#123;        this.dom = document.querySelector(selector);        this.data = data;        this.speed = speed;        this.itemWidth = itemWidth;        this.itemHeigth = itemHeigth;        this.offsetWidth = this.data.length * this.itemWidth + (this.data.length - 1) * spaceWidth;        this.currentOffset = this.initOffset = window.innerWidth;        this.spaceWidth = spaceWidth;        this.init();        this.render();    &#125;    Danmaku.prototype.init = function () &#123;        this.currentOffset = this.initOffset;        this.dom.style.cssText = `width:$&#123;this.offsetWidth&#125;px;display:flex;background:transparent;transform:translate3d($&#123;this.initOffset&#125;px,0,0)`;    &#125;    Danmaku.prototype.render = function () &#123;        let htmlStr = &#39;&#39;;        let styleDom = document.createElement(&#39;style&#39;);        styleDom.innerHTML = `            .danmaku-item&#123;                width:$&#123;this.itemWidth&#125;px;                line-height:$&#123;this.itemHeigth&#125;px;                display:flex;                font-size: 12px;                color: #fff;                background: rgba(0, 0, 0, 0.7);                border-radius: $&#123;this.itemHeigth / 2&#125;px;                align-items: center;                margin-right: $&#123;this.spaceWidth&#125;px;                padding: 0 10px;            &#125;            .danmaku-item:nth-child(odd)&#123;                transform:translate3d(0,$&#123;this.itemHeigth / 3&#125;px,0);            &#125;            .danmaku-item:nth-child(even)&#123;                transform:translate3d(0,-$&#123;this.itemHeigth / 3&#125;px,0);            &#125;            .danmaku-text&#123;                flex: 1;                white-space: nowrap;                overflow: hidden;                text-overflow: ellipsis;                word-break: break-all;            &#125;            .danmaku-img&#123;                width: 26px;                height: 26px;                border-radius: 13px;                object-fit: contain;                margin-right: 10px;            &#125;            `;        document.head.appendChild(styleDom);        this.data.forEach(d =&gt; &#123;            htmlStr += `&lt;div class=&quot;danmaku-item&quot;&gt;                            &lt;img class=&quot;danmaku-img&quot; src=&quot;$&#123;d.icon&#125;&quot;&gt;                            &lt;div class=&quot;danmaku-text&quot;&gt;$&#123;d.time&#125; 获得了星耀款&lt;/div&gt;                        &lt;/div&gt;`;        &#125;);        this.dom.innerHTML = htmlStr;    &#125;;    Danmaku.prototype.playFrame = function () &#123;        this.currentOffset -= this.speed;        this.dom.style.transform = `translate3d($&#123;this.currentOffset&#125;px,0,0)`;        if (this.currentOffset &lt;= -this.offsetWidth) &#123;            this.init();        &#125;        requestAnimationFrame(() =&gt; &#123;            this.playFrame();        &#125;)    &#125;&#125;)();</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现Demo之自动轮播加手势滑动偏移</title>
      <link href="/2022/09/28/html-autoCarouselWithHand/"/>
      <url>/2022/09/28/html-autoCarouselWithHand/</url>
      
        <content type="html"><![CDATA[<h3 id="自动轮播加手势滑动偏移"><a href="#自动轮播加手势滑动偏移" class="headerlink" title="自动轮播加手势滑动偏移"></a>自动轮播加手势滑动偏移</h3><p><strong>ps:</strong> <em>实现一个商品展示自动循环轮播，且用户可以通过手势来控制左右滑动，简易Demo如下</em></p><h4 id="css-Code"><a href="#css-Code" class="headerlink" title="css Code"></a>css Code</h4><pre><code class="css">    * &#123;        padding: 0;        margin: 0;    &#125;    html,    body &#123;        width: 100%;        height: 100%;        overflow: hidden;    &#125;    .container &#123;        width: 100%;        height: 100%;        display: flex;        align-items: center;        justify-content: center;    &#125;    .awrad_outer &#123;        width: 300px;        overflow: hidden;    &#125;    .awrad_list &#123;        width: 900px;        overflow: hidden;    &#125;    .award_list_item &#123;        float: left;        background-color: skyblue;        width: 100px;        height: 100px;        line-height: 100px;        text-align: center;        font-size: 20px;        font-weight: bold;    &#125;</code></pre><h4 id="html-Code"><a href="#html-Code" class="headerlink" title="html Code"></a>html Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Demo之自动轮播加手势滑动偏移&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;awrad_outer&quot;&gt;            &lt;div class=&quot;awrad_list&quot;&gt;                &lt;div class=&quot;award_list_item&quot;&gt;1&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;2&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;3&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;4&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;5&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;6&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;7&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;8&lt;/div&gt;                &lt;div class=&quot;award_list_item&quot;&gt;9&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    var awrad_outer = document.querySelector(&#39;.awrad_outer&#39;);    var awrad_list = document.querySelector(&#39;.awrad_list&#39;);    var offsetVal = 0;    var downX = null;    function move() &#123;        if (downX != null) &#123;            return;        &#125;        offsetVal--;        if (offsetVal &lt;= -600) &#123;            offsetVal = 0;        &#125;        awrad_list.style.transform = `translateX($&#123;offsetVal&#125;px)`;        requestAnimationFrame(move)    &#125;    move();    awrad_outer.addEventListener(&#39;touchstart&#39;, function (e) &#123;        downX = e.targetTouches[0].clientX;    &#125;)    awrad_outer.addEventListener(&#39;touchmove&#39;, function (e) &#123;        let clientX = e.targetTouches[0].clientX;        offsetVal += clientX - downX;        downX = clientX; // 修正参照值        if (offsetVal &gt; 0) &#123;            offsetVal = 0;        &#125; else if (offsetVal &lt; -600) &#123;            offsetVal = -600;        &#125;        awrad_list.style.transform = `translateX($&#123;offsetVal&#125;px)`;    &#125;)    awrad_outer.addEventListener(&#39;touchend&#39;, function (e) &#123;        downX = null;        move();    &#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现Demo之大转盘三连中</title>
      <link href="/2022/09/27/html-lotteryThreeCount/"/>
      <url>/2022/09/27/html-lotteryThreeCount/</url>
      
        <content type="html"><![CDATA[<h3 id="点击抽奖大转盘三连中"><a href="#点击抽奖大转盘三连中" class="headerlink" title="点击抽奖大转盘三连中"></a>点击抽奖大转盘三连中</h3><p><strong>ps:</strong> <em>实现一个抽奖大转盘抽奖三连中，通过canvas来绘制奖品的转盘，其他的背景通过html标签实现，简易Demo如下</em></p><h4 id="html-amp-css-Code"><a href="#html-amp-css-Code" class="headerlink" title="html&amp;css Code"></a>html&amp;css Code</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Demo之大转盘三连中&lt;/title&gt;    &lt;style&gt;        * &#123;            margin: 0;            padding: 0;        &#125;        html,        body &#123;            width: 100%;            height: 100%;            overflow: hidden;        &#125;        .container &#123;            width: 100%;            height: 100%;            overflow-x: hidden;            overflow-y: scroll;        &#125;        .canvas-wrapper &#123;            position: relative;        &#125;        .button &#123;            background: transparent;            outline: none;            border: none;            display: block;            position: absolute;            left: 0;            right: 0;            top: 56vh;            border-radius: 50%;            margin: 0 auto;            width: 100px;            height: 100px;        &#125;        #canvas &#123;            display: block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;canvas-wrapper&quot;&gt;            &lt;!-- 抽奖按钮 --&gt;            &lt;button class=&quot;button&quot;&gt;&lt;/button&gt;            &lt;!-- canvas根据奖品数据绘制奖品圆盘 --&gt;            &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;        &lt;/div&gt;        &lt;div&gt;信息&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="js-Code"><a href="#js-Code" class="headerlink" title="js Code"></a>js Code</h4><pre><code class="js">    // 获取像素比 高清cavas    function getPixelRatio(context) &#123;        var backingStore = context.backingStorePixelRatio ||            context.webkitBackingStorePixelRatio ||            context.mozBackingStorePixelRatio ||            context.msBackingStorePixelRatio ||            context.oBackingStorePixelRatio ||            context.backingStorePixelRatio || 1;        return (window.devicePixelRatio || 1) / backingStore;    &#125;;    // 公共类    function Wheel() &#123;        let cav = document.getElementById(&#39;canvas&#39;);        this.pointerRange = [];        this.pointerIndex = 0;        this.turned = []; //已经转中的下标数组        this.turnTargetRotate = []; //要转的目的数组        this.turnedCount = 0; // 转盘次数        this.startTurn = false; // 开始抽        this.delay = 20;        this.speed = 1; //转速        this.ctx = cav.getContext(&#39;2d&#39;);        this.ratio = getPixelRatio(this.ctx);        this.w = window.innerWidth;        this.h = window.innerHeight;        cav.style.width = this.w + &#39;px&#39;;        cav.style.height = this.h + &#39;px&#39;;        cav.width = this.w * this.ratio;        cav.height = this.h * this.ratio;    &#125;    Wheel.prototype.updatePointerIndex = function (rotate) &#123;        let rotateV = rotate % 360;        let index = this.pointerRange.findIndex(d =&gt; rotateV &lt; d);        this.pointerIndex = index == -1 ? 0 : index;    &#125;    // 转盘类    function AwardRound(&#123;        cx,        cy,        cr = 100,        data = []    &#125;) &#123;        let angleStore = 0;        let sum = 0;        this.cx = cx * wheel.ratio;        this.cy = cy * wheel.ratio;        this.cr = cr * wheel.ratio;        this.count = data.length;        this.data = data.map((d, i) =&gt; &#123;            sum += d.angle;            let prevData = data[i - 1];            angleStore += d.angle + (i - 1 &gt; 0 ? prevData.angle : 0);            let startAngle = - 90 - (d.angle / 2);            d.beginAngle = startAngle / 180 * Math.PI;            d.endAngle = (startAngle + d.angle) / 180 * Math.PI;            if (i == 0) &#123;                d.rotateAngle = 0;            &#125; else &#123;                d.rotateAngle = angleStore;            &#125;            wheel.pointerRange.push(sum - (data[0].angle / 2));            if (d.isTurn) &#123;                let prevItem = wheel.pointerRange[i - 1];                wheel.turnTargetRotate.push(&#123;                    rotate: ((wheel.pointerRange[i] - prevItem) / 2 + prevItem) + 3 * 360,                    index: i                &#125;)            &#125;            return d;        &#125;);    &#125;    // 此处逻辑就是绘制转盘的方法    AwardRound.prototype.render = function () &#123;        let iconW = 36 * wheel.ratio;        this.data.forEach((d, i) =&gt; &#123;            wheel.ctx.save();            wheel.ctx.translate(this.cx, this.cy);            wheel.ctx.rotate((d.rotateAngle) * Math.PI / 360);            wheel.ctx.beginPath();            // 画底盘            wheel.ctx.fillStyle = d.background || &#39;#fdf1e7&#39;;            wheel.ctx.arc(0, 0, this.cr, d.beginAngle, d.endAngle);            wheel.ctx.lineTo(0, 0);            wheel.ctx.fill()            // 名字            wheel.ctx.fillStyle = d.color || &#39;#000&#39;;            wheel.ctx.font = `$&#123;d.fontSize ? d.fontSize * wheel.ratio : 16&#125;px 微软雅黑`;            wheel.ctx.textAlign = &#39;center&#39;;            wheel.ctx.fillText(d.name || &#39;&#39;, 0, - this.cr + 20 * wheel.ratio);            // 图片            if (d.icon) &#123;                wheel.ctx.drawImage(d.icon, -iconW / 2, -this.cr + 40 * wheel.ratio, iconW, iconW);            &#125;            // 浮层            wheel.ctx.fillStyle = &#39;#000&#39;;            wheel.ctx.globalAlpha = i == wheel.pointerIndex || wheel.turned.includes(i) ? 0 : 0.5;            wheel.ctx.arc(0, 0, this.cr, d.beginAngle, d.endAngle);            wheel.ctx.lineTo(0, 0);            wheel.ctx.fill();            wheel.ctx.restore();        &#125;)    &#125;    // 按钮类    function Button(&#123;        cx,        cy    &#125;) &#123;        this.cx = cx * wheel.ratio;        this.cy = cy * wheel.ratio;        this.rotate = 0;    &#125;    Button.prototype.render = function () &#123;        let tmpW = 25 * wheel.ratio;        wheel.ctx.save()        wheel.ctx.translate(this.cx, this.cy);        wheel.ctx.rotate(this.rotate * Math.PI / 180);        wheel.ctx.beginPath()        wheel.ctx.fillStyle = &#39;#FF910B&#39;;        wheel.ctx.arc(0, 0, 50 * wheel.ratio, 0, Math.PI * 2);        wheel.ctx.fill();        wheel.ctx.moveTo(0, 0);        wheel.ctx.lineTo(tmpW, 0);        wheel.ctx.lineTo(0, -80 * wheel.ratio);        wheel.ctx.lineTo(-tmpW, 0);        wheel.ctx.fill();        wheel.ctx.restore();    &#125;    Button.prototype.update = function () &#123;        this.rotate += wheel.speed;        if (wheel.startTurn) &#123; // 开始转了            if (this.rotate &gt;= wheel.turnTargetRotate[wheel.turnedCount].rotate) &#123; // 达到阈值                wheel.delay--; //延时器                if (wheel.delay &gt; 0) &#123;                    // 休息一下                    this.rotate = wheel.turnTargetRotate[wheel.turnedCount].rotate; // 保持抽到位置                    wheel.speed = 0; //停止转动                &#125; else &#123;                    // 转下一次                    wheel.turnedCount++; // 中次+1                    wheel.turned.push(wheel.turnTargetRotate[wheel.turnedCount - 1].index);                    wheel.speed = 20;                    wheel.delay = 20;                    if (wheel.turnedCount &lt; 3) &#123;                        this.rotate = 0;                    &#125;                &#125;            &#125;        &#125;        wheel.updatePointerIndex(this.rotate);    &#125;    // 背景类    function Background() &#123;        let img = new Image()        img.src = &#39;./bg.png&#39;;        this.bgImg = img;    &#125;    Background.prototype.render = function () &#123;        let iconW = (wheel.w - 10) * wheel.ratio;        let iconH = iconW * (846 / 720);        wheel.ctx.drawImage(this.bgImg, 5 * wheel.ratio, wheel.h * wheel.ratio - iconH, iconW, iconH)    &#125;    var awardData = [        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065297220_maYiZc27.jpg&#39;,            name: &#39;感谢参与&#39;,            background: &#39;#fdf1e7&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;13&#39;,            angle: 45,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;AirJordan1&#39;,            background: &#39;#FFB876&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065313260_JDMZ2GTW.jpg&#39;,            name: &#39;iPhone手机&#39;,            background: &#39;#BD1600&#39;,            color: &#39;#FEE28A&#39;,            fontSize: &#39;11&#39;,            angle: 25,            isTurn: true,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;蓝牙音箱&#39;,            background: &#39;#FFDAB2&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065297220_maYiZc27.jpg&#39;,            name: &#39;感谢参与&#39;,            background: &#39;#fdf1e7&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;13&#39;,            angle: 45,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;AirJordan1&#39;,            background: &#39;#FFB876&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065313260_JDMZ2GTW.jpg&#39;,            name: &#39;iPhone手机&#39;,            background: &#39;#BD1600&#39;,            color: &#39;#FEE28A&#39;,            fontSize: &#39;11&#39;,            angle: 25,            isTurn: true,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;蓝牙音箱&#39;,            background: &#39;#FFDAB2&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065297220_maYiZc27.jpg&#39;,            name: &#39;感谢参与&#39;,            background: &#39;#fdf1e7&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;13&#39;,            angle: 45,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;AirJordan1&#39;,            background: &#39;#FFB876&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,        &#123;            icon: &#39;http://mdhw.oss-cn-hangzhou.aliyuncs.com/goods/1652065313260_JDMZ2GTW.jpg&#39;,            name: &#39;iPhone手机&#39;,            background: &#39;#BD1600&#39;,            color: &#39;#FEE28A&#39;,            fontSize: &#39;11&#39;,            angle: 25,            isTurn: true,        &#125;,        &#123;            icon: &#39;&#39;,            name: &#39;蓝牙音箱&#39;,            background: &#39;#FFDAB2&#39;,            color: &#39;#C24603&#39;,            fontSize: &#39;11&#39;,            angle: 25        &#125;,    ];    awardData = awardData.map(d =&gt; &#123;        if (d.icon) &#123;            let img = new Image();            img.src = d.icon;            d.icon = img        &#125;        return d    &#125;)    // 这个需要先执行， 而且得绑定到全局window上    var wheel = new Wheel();     window.onload = function () &#123;        let iconH = (wheel.w - 10) * (846 / 720);        let cx = wheel.w / 2;        let cr = cx - 30;        let cy = wheel.h - iconH + cr + 25;        var btnDom = document.querySelector(&#39;.button&#39;)        var background = new Background();        var awardRound = new AwardRound(&#123;            cx: cx,            cy: cy,            cr: cr,            data: awardData        &#125;);        var button = new Button(&#123;            cx,            cy,        &#125;);        const clickDown = function () &#123;            if (wheel.startTurn) &#123;                btnDom.removeEventListener(&#39;click&#39;, clickDown);                return;            &#125;            button.rotate = 0;            wheel.startTurn = true;            wheel.speed = 20;        &#125;        btnDom.addEventListener(&#39;click&#39;, clickDown)        function doAnimate() &#123;            // 清除画布            wheel.ctx.clearRect(0, 0, 10000, 10000)            // 渲染转盘背景            background.render();            // 渲染转盘            awardRound.render();            // 渲染按钮            button.update();            button.render();            if (wheel.turnedCount &lt; 3) &#123;                requestAnimationFrame(() =&gt; &#123;                    doAnimate();                &#125;)            &#125;        &#125;        doAnimate();    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
